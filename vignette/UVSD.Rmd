---
title: "UVSD Modeling"
author: "William Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(optimx)
library(foreach)
library(rstan)
library(tidybayes)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{r load_data}
load(file.path(root_dir, "data","SvDPRec.Rdata"))
test <- select(test, -list)
```

## Subject-wise Maximum Likelihood Estimation
```{r SDT_model_functions}
SDT <- function(d, s, crit) {

  # if (is.unsorted(rev(crit))) {
  #   # warning("Criterion locations will be sorted in descending order")
  #   crit <- sort(crit, decreasing = TRUE)
  # }
  
  if (length(d) != 2L) {
    stop("Only 2 target distributions may be specified")
  }

  if (length(s) == 1L) {
    s <- c(s, s)
  }
  
  FAR <- pnorm(crit, lower.tail = FALSE)
  HR_W <- pnorm(crit, mean = d[1], sd = s[1], lower.tail = FALSE)
  HR_S <- pnorm(crit, mean = d[2], sd = s[2], lower.tail = FALSE)
  
  return(list("HitRate_Strong" = HR_S,
              "HitRate_Weak" = HR_W,
              "FalseAlarmRate" = FAR)
         )
}

SDT_LL <- function(H_S, H_W, FA, ...) {

  SDT_preds <- SDT(...)
  LL <- c(dbinom(H_S$H_S, size = H_S$S_N, prob = SDT_preds$HitRate_Strong, log=TRUE),
          dbinom(H_W$H_W, size = H_W$W_N, prob = SDT_preds$HitRate_Weak, log=TRUE),
          dbinom(FA$FA, size = FA$FA_N, prob = SDT_preds$FalseAlarmRate, log=TRUE)
          )
  return(-sum(LL))
}

## A small wrapper around the likelihood function that makes it suitable
## for optimization. It takes the parameter values as a named vector, matching the 
## vector element names with argument names for the SDT_LL function. It also detects
## whether the likelhood function is infinite (which optimx et al. doesn't like), and
## instead returns the largest representable on the current machine.

fit_SDT <- function(theta, ...) {

  negLL <- SDT_LL(d = theta[c("d.W","d.S")],
                  s = theta[startsWith(names(theta), "s")],
                  crit = theta[c("crit1", "crit2", "crit3")],
                  ...)
  if (is.infinite(negLL) || is.nan(negLL)) {
    negLL <- .Machine$double.xmax
  }

  return(negLL)
}
```

```{r cell_counts}
delayed_counts_by_sub_bias <- filter(test, !is.na(type)) %>%
  select(-starts_with("speeded")) %>%
  rename(correct = delayed_correct) %>%
  count(subject, strength, pOld, correct) %>%
  complete(subject, strength, pOld, correct,
           fill = list(n=0)) %>%
  unite(col = "resp_type", strength, correct) %>%
  spread(resp_type, n) %>%
  rename(FA = L_FALSE, CR = L_TRUE,
         M_S = S_FALSE, H_S = S_TRUE,
         M_W = W_FALSE, H_W = W_TRUE) %>%
  mutate(FA_N = FA + CR,
         S_N = M_S + H_S,
         W_N = M_W + H_W) %>%
  select(subject, pOld, FA, FA_N, H_S, S_N, H_W, W_N)

```

```{r MLE_fit, cache=TRUE}
UVSD_fits <- foreach(sub = split(delayed_counts_by_sub_bias,
                                 delayed_counts_by_sub_bias$subject)
                     ) %do% {

  fit <- optimx(par = c("d.W"=1.5, "d.S"=2.5, "s" = 1.2,
                        crit = c(1.25, 1, .75)),
                fn = fit_SDT,
                method = "nlminb",
                itnmax = 3000,
                lower = c(0, 0, 0.1, 0.1, -3, -3, -3),
                upper = c(5, 5, 2, 2, 3, 3, 3),
                control = list(kkt=FALSE),
                H_S = sub[c("H_S","S_N")],
                H_W = sub[c("H_W", "W_N")],
                FA = sub[c("FA", "FA_N")]
              )
  ## Add subject number as first column of fit table
  fit$subject <- sub$subject[1]
  fit <- select(fit, subject, d.W:convcode)
  
  ## Order the criterion columns from largest (most conservative) to lowest (most liberal)
  crit_columns <- startsWith(names(fit), "crit")
  decreasing_crit_values <- sort(unlist(fit[crit_columns]), decreasing = TRUE)
  names(decreasing_crit_values) <- paste0("crit", 1:length(decreasing_crit_values))
  fit[crit_columns] <- as.list(decreasing_crit_values)
  
  ## This is a max lik fit, so "Value" so it should be renamed and have sign flipped (as optimization routine minimized negative LL)
  fit <- rename(fit, LL = value)
  fit <- mutate(fit, LL = -LL)
  
  }

UVSD_fits <- bind_rows(UVSD_fits)
```

```{r formatted_column_names}
parameter_colnames <- c("d'<sub>W</sub>", "d'<sub>S</sub>", "\u03c3",
                        "C<sub>c</sub>", "C<sub>n</sub>", "C<sub>l</sub>")

hyperparam_colnames <- rep(c("\u03BC", "\u03c3"), 6)
```


```{r MLE_fit_display, dependson=c("MLE_fit")}
MLE_param_means <- colMeans(select(UVSD_fits, d.W:crit3))

kable(UVSD_fits, digits=3, escape = FALSE,
      caption = "MLE parameter estimates",
      col.names = c("Subject", parameter_colnames, names(UVSD_fits)[8:12])) %>%
  kableExtra::kable_styling(full_width = FALSE, position="left")

kable(matrix(MLE_param_means, ncol=6), digits=3, escape = FALSE,
      caption = "Average parameters",
      col.names = parameter_colnames) %>%
  kableExtra::kable_styling(full_width = FALSE, position="left")
```

## Hierarchical Bayesian Estimation
### Will's Stan Model
```{stan stan_model_external, eval=FALSE, echo=TRUE, output.var='modelstring', code=readLines(file.path(root_dir, "R","UVSD.stan"))}
```

```{r stan_model, cache=TRUE, results="hide", cache.extra = tools::md5sum(file.path(root_dir, "R","UVSD.stan"))}
# Create an array suitable for passing into stan, so it can be turned into an array of matrices
# The final produce should be 14 x 3 x 3, with subject along dim 1, bias level (conservative --> liberal) along dim 2,
# and strength (lure, weak, strong) along dim 3.
delayed_counts_by_sub_bias <- arrange(delayed_counts_by_sub_bias, subject, desc(pOld)) %>%
  mutate(H_S = replace(H_S, H_S == S_N, H_S[H_S == S_N]-1))

yes_matrix = t(as.matrix(delayed_counts_by_sub_bias[c('FA','H_W','H_S')]))
dim(yes_matrix) <- c(3, 3, 14)
dimnames(yes_matrix) <- list("Strength" = c("Lure","Weak","Strong"),
                             "Bias" = c("Lib.","Neutral","Cons."),
                             "Subject" = 101:114)
yes_matrix <- aperm(yes_matrix, c(2,1,3))

trial_matrix = t(as.matrix(delayed_counts_by_sub_bias[c('FA_N','W_N','S_N')]))
dim(trial_matrix) <- c(3, 3, 14)
dimnames(trial_matrix) <- list("Strength" = c("Lure","Weak","Strong"),
                               "Bias" = c("Lib.","Neutral","Cons."),
                               "Subject" = 101:114)
trial_matrix <- aperm(trial_matrix, c(2,1,3))

standata <- list(yeses = yes_matrix, trials = trial_matrix,
                 Nsubs = length(unique(delayed_counts_by_sub_bias$subject)))

fit <- stan(file = file.path(root_dir, "R","UVSD.stan"),
            data = standata,
            pars = paste0("eta[", 1:standata$Nsubs, "]"),
            include = FALSE,
            iter = 3000,
            chains = 4,
            seed = 1235,
            init_r = 1,
            control = list(adapt_delta=.99)
            )
```

```{r parameter_summaries, cache=TRUE, dependson=c("stan_model")}
posterior <- as.data.frame(extract(fit))

## Subject level parameters
sub_level_params <- select(posterior, contains("_sub")) %>%
  summarise_all(.funs = funs(mean, median)) %>%
  gather("parameter","value") %>%
  separate(parameter, into = c("parameter", "statistic"),
         sep = "(?<=[0-9])_", fill = "right") %>%
  separate(parameter, into = c("parameter","subject","which"),
           sep = "\\.", fill = "right", convert = TRUE)

subject_dprimes <- filter(sub_level_params, parameter=="mu_sub", statistic=="mean") %>%
  mutate(strength = ifelse(which==1,"Weak","Strong")) %>%
  select(subject, strength, value) %>%
  spread(strength, value) %>%
  select(subject, Weak, Strong)

sub_sigma <- filter(sub_level_params, parameter=="sigma_sub", statistic=="mean") %>%
  select(subject, parameter, value) %>%
  spread(parameter, value) %>%
  rename(sigma = sigma_sub)

sub_crit <- filter(sub_level_params, parameter=="crit_sub", statistic=="mean") %>%
  select(subject, parameter, which, value) %>%
  unite("parameter", parameter, which) %>%
  spread(parameter, value) %>%
  select(subject, crit_sub_3, crit_sub_2, crit_sub_1)

sub_param_means <- inner_join(subject_dprimes, sub_sigma, by = "subject") %>%
  inner_join(sub_crit, by="subject")

## Hyper Parameters
hyper <- select(posterior, contains("_pop")) %>%
  summarise_all(.funs = funs(mean)) %>%
  mutate(sigma_pop = exp(log_sigma_pop),
         sigma_pop_SD = exp(log_sigma_pop_SD)) %>%
  select(mu_pop.1, mu_pop_SD.1, mu_pop.2, mu_pop_SD.2, sigma_pop, sigma_pop_SD,
         crit_pop.3, crit_pop_SD.3, crit_pop.2, crit_pop_SD.2, crit_pop.1, crit_pop_SD.1)
```

```{r posterior_display, dependson=c('parameter_summaries')}
kable(sub_param_means, digits=3, escape = FALSE,
      caption = "Subject-level parameter means",
      col.names = c("Subject", parameter_colnames)) %>%
  kable_styling(full_width = FALSE, position = "left") 

kable(hyper, digits=3, escape = FALSE,
      caption = "Hyperparameter means",
      col.names = hyperparam_colnames) %>%
  kable_styling(full_width = FALSE, position = "left") %>%
  add_header_above(setNames(rep(2, 6), parameter_colnames),
                   escape = FALSE)
```

### Jeff's JAGS Model
```{r jags_model_source_code, comment=""}
cat(readLines(file.path(root_dir, "R", "uv.bug")), sep="\n")
```

```{r jags_model_posterior}
## loads mcmc.list object named 'UVSD_jags_posterior'
load(file = file.path(root_dir, "data", "uvPosts.RData"))

jags_posterior_subjects <- spread_draws(UVSD_jags_posterior, mu[subject], se[subject], lsig[subject],
                                        bec[subject], c[subject], bel[subject]) %>%
  mutate(strong = mu + se,
         sigma = exp(lsig),
         crit1 = (mu/2) + c + bec,
         crit2 = (mu/2) + c,
         crit3 = (mu/2) + c + bel) %>%
  select(.chain:subject, weak=mu, strong, sigma, crit1, crit2, crit3) %>%
  mean_hdi()

jags_posterior_hyper <- spread_draws(UVSD_jags_posterior, Mmu, SDmu, Mse, SDse, Mlsig, SDlsig,
                                     Mbec, Mc, Mbel, SDc, SDbe) %>%
  mutate(strong = Mmu + Mse,
         sigma = exp(Mlsig),
         SDsigma = exp(SDlsig),
         crit1 = (Mmu/2) + Mc + Mbec,
         crit2 = (Mmu/2) + Mc,
         crit3 = (Mmu/2) + Mc + Mbel) %>%
  select(.chain:.draw, weak=Mmu, SDweak=SDmu, strong, SDstrong=SDse, sigma, SDsigma,
         crit1, SDbe, crit2, SDc, crit3) %>%
  mean_hdi()
```

```{r jags_posterior_display}
kable(select(jags_posterior_subjects, -contains(".")),
      digits=3, escape = FALSE,
      caption = "Subject-level parameter means",
      col.names = c("Subject", parameter_colnames)) %>%
  kable_styling(full_width = FALSE, position = "left") 

kable(select(jags_posterior_hyper, -contains(".")),
      digits=3, escape = FALSE,
      caption = "Hyperparameter means",
      col.names = hyperparam_colnames[-length(hyperparam_colnames)]) %>%
  kable_styling(full_width = FALSE, position = "left") %>%
  add_header_above(c(setNames(rep(2, 5), parameter_colnames[1:(length(parameter_colnames)-1)]), 
                     "C<sub>l</sub>"=1),
                   escape = FALSE)
```

