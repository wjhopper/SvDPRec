---
title: "Diffusion SDT Parameter Recovery"
author: "Will Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(Rcpp)
library(kableExtra)
library(optimx)
library(foreach)
library(rtdists)
library(ggplot2)
library(dplyr)
library(tidyr)
library(RcppParallel)
library(dqrng)
library(iterators)
root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{r diffusion_functions}
libdir <- file.path(root_dir, "src", "libs")
if (!dir.exists(libdir)) {
  dir.create(libdir)
}
sourceCpp(file.path(root_dir, "src", "diffusion.cpp"),
          cacheDir = libdir)

sample_parameters <- function(N=500) {

  parameters <- data.frame(id = 1:N,
                           a = runif(N, .5, 1.5),
                           v = rnorm(N),
                           t0 = runif(N, 0, .5),
                           z = runif(N),
                           sz = runif(N, 0, .5),
                           sv = rexp(N, 2),
                           st0 = runif(N, 0, .25),
                           crit_old = runif(N, -1,0),
                           crit_new = runif(N, 0, 1)
                           )
  return(parameters)
}

p_diffusion_SDT <- function(x, cutoffs) {
  p <- numeric(length(cutoffs))
  RT <- x[,'RT']
  for (i in 1:length(cutoffs)) {
    p[i] <- sum(RT <= cutoffs[i])
  }
  return(p)
}

summary.diffusion_SDT <- function(x, quantiles=c(.1, .3, .5, .7, .9, 1)) {
  
  x <- as_data_frame(unclass(x))
  
  speeded_quantiles <- group_by(x, speeded_resp) 
  speeded_quantiles <- filter(speeded_quantiles, n() >= 6)
  speeded_quantiles <- summarise(speeded_quantiles,
      quantiles = list(
        data.frame(quantile = quantiles,
                   RT = quantile(RT, quantiles),
                   stringsAsFactors = FALSE
                   )
        )
      )
  speeded_quantiles <- ungroup(speeded_quantiles)

  joint_counts <- group_by(x, speeded_resp, delayed_resp)
  joint_counts <- nest(joint_counts, RT , .key="raw_RT")
  joint_counts <- left_join(speeded_quantiles, joint_counts,
                            by = "speeded_resp")
  joint_counts <- group_by(joint_counts, speeded_resp, delayed_resp)
  joint_counts <- mutate(joint_counts,
                         bin_counts = list(p_diffusion_SDT(x = raw_RT[[1]],
                                                           cutoffs = quantiles[[1]]$RT
                                                           )
                                           )
                          )
  joint_counts <- select(joint_counts, -raw_RT)
  joint_counts <- unnest(joint_counts, quantiles, bin_counts)
  joint_counts <- mutate(joint_counts, 
                         bin_counts = diff(c(0, bin_counts)))
  joint_counts <- ungroup(joint_counts)
  joint_counts <- select(joint_counts,
                         speeded_resp, delayed_resp, quantile, RT, bin_counts)
  joint_counts <- arrange(joint_counts, speeded_resp, delayed_resp)

  return(joint_counts)
}

diffusion_obj <- function(theta, data, fixed=NULL, Nsim=5e4){

  theta <- c(theta, fixed)
  boundaries <- c(0,1) # Boundaries to loop over

  sim_data <- diffusion_SDT(N=Nsim, a = theta["a"], z = theta['z'],
                            v = theta["v"], sv = theta["sv"],
                            t0 = theta["t0"], st0 = theta["st0"],
                            crit = theta[c("crit_old","crit_new")],
                            )

  p <- numeric(nrow(data))
  start <- 1

  for (sp_resp in boundaries) {
    for (del_resp in boundaries) {

      resp_index <- data$speeded_resp == sp_resp &
                    data$delayed_resp == del_resp
      sim_responses <- sim_data[,'speeded_resp'] == sp_resp &
                                sim_data[,'delayed_resp'] == del_resp

      # Only proceed if this isn't a missing cell
      if (any(resp_index) && any(sim_responses)) {

        cutpoints <- data$RT[resp_index]
        n_cutpoints <- length(cutpoints)
        cutpoints[n_cutpoints] <- Inf

        # Compute porportion below each cutoff
        resp_proportions <- p_diffusion_SDT(sim_data[sim_responses, , drop=FALSE],
                                            cutpoints)
        # Convert to proportion between each cutoffs
        resp_proportions <- c(resp_proportions[1],
                              diff(resp_proportions)
                              )

        p[start:(start + n_cutpoints - 1)] <- resp_proportions
        start <- start + n_cutpoints
      }
    }
  }
  
  empty_preds <- p == 0
  if (any(empty_preds)) {
    p[empty_preds] <- 5e-06
  }

  filled_cells <- data$bin_counts != 0
  obs_counts <- data$bin_counts[filled_cells]
  exp_counts <- (p/Nsim)*sum(data$bin_counts)
  exp_counts <- exp_counts[filled_cells]
  g2 <- 2*sum(obs_counts*log(obs_counts/exp_counts))
  # if (is.nan(g2) || is.infinite(g2)) {
  #   browser()
  # }
  # cat(g2, "\n")
  return(g2)
}
```

```{r start_cluster}
RcppParallel::setThreadOptions(1)

cl <- parallel::makeCluster(parallel::detectCores(),
                            outfile = "",
                            methods = FALSE)
invisible(parallel::clusterCall(cl, function(x) {.libPaths(x)},
                                x = .libPaths())
          )
invisible(parallel::clusterCall(cl, function(x) {Rcpp::sourceCpp(x)},
                                x = file.path(root_dir, "src", "diffusion.cpp"))
          )
doParallel::registerDoParallel(cl)
```

```{r null_g2, eval=FALSE}
theta <- c(a = 0.634, v = 0.0465, sv = 2.534, t0 = 0.0782, st0 = 0.1888,
           z = 0.4585, sz = 0.0723, crit_old = -0.355, crit_new = 0.681)
G2 <- foreach(i=1:10000,
              .noexport = c("diffusion_SDT"),
              .packages = c("optimx", "dplyr" , "tidyr"),
              .combine = c) %dopar% {
    raw_data <- diffusion_SDT(1000, a = theta["a"], z = theta['z'],
                              v = theta["v"], sv = theta["sv"],
                              t0 = theta["t0"], st0 = theta["st0"],
                              crit = theta[c("crit_old","crit_new")]
                              )
    data <- summary.diffusion_SDT(raw_data)
    g2 <- diffusion_obj(theta, data=data, Nsim = 1e5)
    g2
  }
```

```{r null_g2_plot}
G2 <- G2[!is.nan(G2)]
densities <- hist(G2, freq = FALSE, breaks=seq(0,max(G2)+1, 1), 
     main=expression(paste(G^2, " for Joint Counts")))
xaxis <- seq(0, max(G2), .1)
lines(xaxis, dchisq(xaxis, 23), col="red", lwd=2)
legend(x=max(G2)-20, y = max(densities$density),
       col=c("red"),
       lty=c(1),
       legend=expression(chi[23]^2),
       lwd=2, bty = 'n')
```

```{r sample_parameters}
parameters <- sample_parameters(1000)

samples <- foreach(p_row = iterators::iter(select(parameters, -id), "row")) %do%
  {

    theta <- unlist(p_row)
    raw_data <- diffusion_SDT(1000, a = theta["a"], z = theta['z'],
                              v = theta["v"], sv = theta["sv"],
                              t0 = theta["t0"], st0 = theta["st0"],
                              crit = theta[c("crit_old","crit_new")]
                             )
    data <- summary.diffusion_SDT(raw_data)
    list(theta=theta, data=data)
  }
rm(data, raw_data, theta, p_row)
```

```{r null_g2_recovery, cache=TRUE, dependson=c("diffusion_functions")}
null_fit_optimx <- foreach(s = samples,
                           .noexport = c("diffusion_SDT"),
                           .packages = c("optimx", "dplyr" , "tidyr")
                           ) %dopar% {

    fit <- optimx(s$theta,
                  fn = diffusion_obj,
                  method = c("L-BFGS-B"),
                  itnmax = 1000,
                  lower = c(0, -10, 0,    0, 0,    0, 0,    -4, -4),
                  upper = c(4,  10, 0.75, 1, 0.75, 6, 0.75,  4,  4),
                  control = list(kkt=FALSE, maxit=1000, starttests=FALSE),
                  data = s$data
                  )
    fit
  }

null_fits <- lapply(null_fit_optimx, tibble::rownames_to_column, var="method") %>%
  bind_rows()
null_GOF <- select(null_fits, fevals, gevals, niter, convcode, value)
null_bf_parameters <- select(null_fits, !!!names(parameters)[-1])
```

```{r null_g2_recovery_plot}
nCells <- sapply(fits, function(x) nrow(x$data))
weights <- as.vector(table(nCells))/length(fits)

densities <- hist(GOF$value, freq = FALSE,
                  breaks=seq(0,max(GOF$value)+1, 1), 
                  main=expression(paste(G^2, " for Joint Counts")))
xaxis <- seq(0, max(GOF$value), .1)
chi_density <-
  dchisq(xaxis, 5)*weights[1] +
  dchisq(xaxis, 11)*weights[2] +
  dchisq(xaxis, 17)*weights[3] +
  dchisq(xaxis, 23)*weights[4]

lines(xaxis, chi_density, col="red", lwd=2)
legend(x=xaxis[length(xaxis)]-20, y = max(densities$density),
       col=c("red"),
       lty=c(1),
       legend=expression(chi[23]^2),
       lwd=2, bty = 'n')
```

```{r random_theta_recovery, cache=TRUE, dependson=c("diffusion_functions")}
r_fits <- foreach(p_row = iterators::iter(parameters[1:50, -1], "row"),
                .noexport = c("diffusion_SDT"),
                .packages = c("optimx", "dplyr" ,"tidyr")
                ) %dopar% {

    true_theta <- unlist(p_row)
    raw_data <- diffusion_SDT(1000, a = true_theta["a"], z = true_theta['z'],
                              v = true_theta["v"], sv = true_theta["sv"],
                              t0 = true_theta["t0"], st0 = true_theta["st0"],
                              crit = true_theta[c("crit_old","crit_new")]
                             )
    data <- summary.diffusion_SDT(raw_data)

    best_value <- Inf
    n <- 1
    while (n <= 2) {

      starting_theta <- unlist(sample_parameters(1))
      fit <- optimx(starting_theta,
                    fn = diffusion_obj,
                    method = c("L-BFGS-B"),
                    itnmax = 1000,
                    lower = c(0, -10, 0,    0, 0,    0, 0,    -4, -4),
                    upper = c(4,  10, 0.75, 1, 0.75, 6, 0.75,  4,  4),
                    control = list(kkt=FALSE, maxit=1000, starttests=FALSE),
                    data = data
                    )

      if (fit$value < best_value) {
        best_value <- fit$value
        best_fit <- fit
      }
      
      n <- n + 1
    }

    if (best_value == Inf) {
      best_fit <- fit
    }
    
    list(true_theta=true_theta, starting_theta=starting_theta,
         data=data, fit=best_fit)
  }
```

```{r stopCluster, eval=FALSE}
parallel::stopCluster(cl)
```

```{r tidy_recovered_params}
recovered_fits <- lapply(lapply(r_fits, `[[`, 'fit'),
                         tibble::rownames_to_column, var="method") %>%
  bind_rows()
recovered_GOF <- select(recovered_fits, fevals, gevals, niter, convcode, value)
recovered_parameters <- select(recovered_fits, !!!names(parameters)[-1])
```

```{r old, eval=FALSE}
# p_names <- c("v", "sv", "a", "t0", "st0", "z", "sz", "crit_old", "crit_new")
# print(sprintf("Dataset %d, iteration %i", d$id[1], n))
# parameters["v"] <- rnorm(1, 0, 1)
# parameters["sv"] <- .001 + min(rexp(1, rate = 2), 5)
# parameters["a"] <- runif(1, 0.001, 1.5)
# parameters["t0"] <- runif(1, 0.001, .5)
# parameters["st0"] <- runif(1, 0.001, .25)
# parameters["z"] <- runif(1, 0.001, 1)
# parameters["sz"] <- runif(1, 0.001, .5)
# parameters["crit_old"] <- runif(1, -1, 0)
# parameters["crit_new"] <- runif(1, 0, 1)
```

```{r random_recovery_plot}
all_params <- bind_rows(real = parameters,
                        est = tibble::rowid_to_column(recovered_parameters,
                                                      var = "id"),
                        .id="type")
x <- all_params %>%
  gather(key="parameter",value = "value", -id, -type) %>%
  spread(key="type",value="value")

ggplot(x, aes(x=real,y=est)) +
  geom_point() +
  facet_wrap(~parameter, nrow=3, scales = "free")
```
