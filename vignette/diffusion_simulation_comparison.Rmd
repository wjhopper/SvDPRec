---
title: "Diffusion Simulation Comparisons"
author: "Will Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options:
  chunk_output_type: console
---

```{css, echo=FALSE}
p { font-size: 16px; }
```

This documents reports a comparison between 3 implementations of the Ratcliff diffusion model. The implementations are:

1. The "reference" implementation in the `rtdists` R package, which uses the `fast_dm` code of Voss & Voss.
2. A pure R simulation implementation by Hopper, sourced from the accompanying `DiffSim.R` file.
3. A C++ simulation implementation by Hopper (using Rcpp and RcppParallel), sourced from the accompanying `diffusion.cpp` file.

To compare these implementations, we will sample 500 random sets of parameters, simulate responses from the diffusion model under each implementation, and measure the number of responses in the bins defined by the .1, .3, .5, .7, and .9 quantiles.

The RT quantile cutoffs for each bin are determined using the qdiffusion function (the defective quantile function from the `rtdists` package). 

Counts from the model implementation in the `rtdists` package are generated using both the `rdiffusion` function (for sampling random trials) and the `pdiffusion` function (the cumulative distribution function), which is referred to as the "true" counts. Random draws are obtained in the `rdiffusion` function by taking samples from a random uniform distribution between 0 and 1, and running each samples through the quantile function to obtain an RT and response.

The code for running these simulations is below. All simulations are performed using 50,000 random trials.

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center")
library(rprojroot)
library(Rcpp)
library(kableExtra)
library(optimx)
library(foreach)
library(rtdists)
library(ggplot2)
library(dplyr)
library(tidyr)
library(RcppParallel)
library(dqrng)
library(iterators)
library(doRNG)
root_dir <- rprojroot::is_rstudio_project$find_file()
RcppParallel::setThreadOptions(1)
```

```{r functions}
source(file.path(root_dir, "R", "DiffSim.R"))
diffusion_SDT_R <- diffusion_SDT

sourceCpp(file.path(root_dir, "src", "diffusion.cpp"))

sample_parameters <- function(N=500) {
  
  parameters <- data.frame(id = 1:N,
                           a = runif(N, .5, 1.5),
                           v = rnorm(N),
                           t0 = runif(N, 0, .5),
                           z = runif(N, .1, .9),
                           sz = runif(N, .1, .9),
                           sv = rexp(N, 2),
                           st0 = runif(N, 0, .25),
                           crit_old = runif(N, -1,0),
                           crit_new = runif(N, 0, 1)
                           )
  parameters$z <- parameters$z * parameters$a # convert relative to absolute 
  dist_to_closest_boundary <- pmin(parameters$a - parameters$z,
                                   parameters$z)
  parameters$sz <- parameters$sz * dist_to_closest_boundary
  return(parameters)
}

```

```{r start_cluster, echo=FALSE}
cluster_setup <- function(cppFiles, threads=RcppParallel::defaultNumThreads(), lib_paths = .libPaths()) {
  .libPaths(lib_paths)
  for (f in cppFiles) {
    Rcpp::sourceCpp(f)
  }
  RcppParallel::setThreadOptions(threads)
  set_diffusion_SDT_seed(42)
}

cl <- parallel::makeCluster(parallel::detectCores(),
                            outfile = "",
                            methods = FALSE)
invisible(parallel::clusterCall(cl, cluster_setup,
                                cppFiles = file.path(root_dir, "src", "diffusion.cpp"),
                                threads  = 1,
                                lib_paths = .libPaths()
                                )
          )
doParallel::registerDoParallel(cl)
doRNG::registerDoRNG(seed=42)
```

```{r simulations, cache=TRUE, cache.extra=list(diffusion_SDT_R, tools::md5sum(file.path(root_dir, "src", "diffusion.cpp")))}
set.seed(42)
parameters <- sample_parameters(500)

samples <- foreach(p_row = iterators::iter(select(parameters, -id), "row"),
                   .noexport = c("diffusion_SDT"),
                   .packages = c("optimx", "dplyr" , "tidyr" ,"rtdists")) %dopar% 
  {
    Nsim = 50000
    theta <- unlist(p_row)
    p <- p1 <- p2 <- p3 <- numeric(12)

    my_data <- diffusion_SDT(Nsim, a = theta["a"], z = theta['z'],
                             v = theta["v"], sv = theta["sv"],
                             t0 = theta["t0"], st0 = theta["st0"],
                             crit = theta[c("crit_old","crit_new")]
                             )
    my_data_R <- diffusion_SDT_R(Nsim, a = theta["a"], z = theta['z'],
                                 v = theta["v"], sv = theta["sv"],
                                 t0 = theta["t0"], st0 = theta["st0"],
                                 crit = theta[c("crit_old","crit_new")]
                                 )
    rtdists_data <- rdiffusion(Nsim, a = theta["a"], z = theta['z'],
                               v = theta["v"], sv = theta["sv"],
                               t0 = theta["t0"], st0 = theta["st0"]
                               )
    rtdists_data$response <- as.numeric(rtdists_data$response) - 1
    rtdists_data <- as.matrix(rtdists_data)
    colnames(rtdists_data) <- c("RT", "speeded_resp")

    start <- 1
    end <- 6
    for (sp_resp in c(0, 1)) {
      x <- qdiffusion(c(.1, .3, .5, .7, .9, 1),
                      sp_resp + 1,
                      a = theta["a"], z = theta['z'],
                      v = theta["v"], sv = theta["sv"],
                      t0 = theta["t0"], st0 = theta["st0"],
                      scale_p = TRUE)
      x[is.na(x)] <- 0
      p[start:end] <- pdiffusion(x,
                                 sp_resp + 1,
                                 a = theta["a"], z = theta['z'],
                                 v = theta["v"], sv = theta["sv"],
                                 t0 = theta["t0"], st0 = theta["st0"]
                                 )
      for (i in 1:6) {
        p1[start + (i-1)] <- sum(my_data[my_data[,'speeded_resp'] == sp_resp, 'RT'] < x[i])
        p2[start + (i-1)] <- sum(rtdists_data[rtdists_data[,'speeded_resp'] == sp_resp, 'RT'] < x[i])
        p3[start + (i-1)] <- sum(my_data_R[my_data_R[,'speeded_resp'] == sp_resp, 'RT'] < x[i])
      }
      start <- start + 6
      end <- end + 6
    }

    data.frame(quantiles=c(.1, .3, .5, .7, .9, 1),
               response = rep(0:1, each=6),
               true=p*Nsim, mine=p1, rtdists=p2, mine_R=p3)
  }
```

```{r stopcluster, echo=FALSE}
parallel::stopCluster(cl)
```

```{r tidy}
within_bin_counts <- function(x) {
  diff(c(0, x))
}

names(samples) <- 1:length(samples)
samples <- bind_rows(samples, .id="id") %>%
  filter(!is.na(true)) %>%
  group_by(id, response) %>%
  mutate_at(c("mine","mine_R","rtdists","true"), within_bin_counts)
```

## Results

The 6 scatter plots below compare the counts in each bin between all pairs of model implementations. Several relationships are readily apparent:

1. The `rdiffusion` and `pdiffusion` functions produce highly consistent results
2. The `diffusion_SDT` and `diffusion_SDT_R` functions produce highly consistent results.
3. The two simulation implementations by Hopper produce qualitatively different results than the reference implementation.

```{r count_plots, echo=FALSE, fig.width=7, fig.height=8.5}
ggplot(samples, aes(x=mine, y=true, color=factor(response))) + 
  geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("diffusion_SDT") +
  ylab("pdiffusion") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("True vs. diffusion_SDT in C++")

ggplot(samples, aes(x=mine_R, y=true, color=factor(response))) + 
  geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("diffusion_SDT") +
  ylab("pdiffusion") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("True vs. diffusion_SDT in R")

ggplot(samples, aes(x=mine, y=rtdists, color=factor(response))) +
  geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("diffusion_SDT") +
  ylab("rdiffusion") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("rdiffusion vs. diffusion_SDT in C++")

ggplot(samples, aes(x=mine_R, y=rtdists, color=factor(response))) +
  geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("diffusion_SDT R Version ") +
  ylab("rdiffusion") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("rdiffusion vs. diffusion_SDT in R")

ggplot(samples, aes(x=rtdists, y=true, color=factor(response))) +
  geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("rdiffusion") +
  ylab("pdiffusion") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("True vs. rdiffusion")

ggplot(samples, aes(x=mine_R, y=mine, color=factor(response))) + 
  geom_point() +
  geom_abline(slope=1, intercept=0) +
  facet_grid(quantiles~response,
             labeller = labeller(quantiles=label_value,
                                 response = label_both)
             ) +
  xlab("diffusion_SDT_R") +
  ylab("diffusion_SDT") +
  scale_color_discrete(guide=FALSE) +
  ggtitle("diffusion_SDT in C++ vs. diffusion_SDT in R")
```

The nature of this qualitative difference is most clearly seen in the counts falling into the first decile bin. The two simulation methods, diffusion_SDT` and `diffusion_SDT_R`, produce far fewer response in this bin than the `rdiffusion` and `pdiffusion` implementations. Complementing this difference, the two simulation methods produce more responses in the bin defined by the .9 quantile than the reference implementation. In other words, it appears the RT's produced by the two simulation methods are slower than the reference implementation.

## RT Densities
To investigate the nature of this difference further, let's compare the RT distribution density estimates between these implementations. Because the `rdiffusion` and `pdiffusion` strongly agree, and the the `diffusion_SDT` and `diffusion_SDT_R` functions also strongly agree, we'll focus on comparing one member from each group. Here, we choose to focus on the C++ simulation (the `diffusion_SDT` function) and the `rdiffusion` function.

We'll do two new simulations, using the set of parameters that produced the smallest absolute differences between methods, and the set of parameters that produced the largest absolute differences between methods. We begin with the "best" set of parameters:

```{r differences, fig.height=10, fig.width=8}
X <- ungroup(samples) %>%
  filter(quantiles==.1) %>%
  mutate(id = as.numeric(id),
         diff = true - mine)
Y <- inner_join(parameters,
                select(X, id, response, diff),
                by="id"
                )

```

```{r good_RT_dist, cache=TRUE, cache.extra=list(diffusion_SDT_R, tools::md5sum(file.path(root_dir, "src", "diffusion.cpp"))), fig.width=8}

theta <- filter(Y, abs(diff) == min(abs(diff))) %>%
  slice(1) %>%
  select(a, v, t0, z, sz, sv, st0)

kable(theta,format = "html", digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE)

theta <- unlist(theta)

A <- as.data.frame(diffusion_SDT(1e6, a = theta["a"], z = theta['z'],
                                 v = theta["v"], sv = theta["sv"],
                                 t0 = theta["t0"], st0 = theta["st0"]
                                 )
                   ) %>%
  select(rt = RT, response = speeded_resp)

B <- rdiffusion(1e6, a = theta["a"], z = theta['z'],
                v = theta["v"], sv = theta["sv"],
                t0 = theta["t0"], st0 = theta["st0"]
                ) %>%
  mutate(response = as.numeric(response) - 1)

rt_distributions <- bind_rows("diffusion_SDT" = A,
                               "rdiffusion" = B,
                               .id = "type") %>%
  filter(rt <= quantile(rt, .999))

ggplot(rt_distributions, aes(x=rt,color=type)) +
  geom_density() +
  facet_grid(~response, labeller = label_both) +
  theme(legend.position = "top")
rm(A, B)
```

Now, the "worst" set
```{r bad_RT_dist, cache=TRUE, cache.extra=list(diffusion_SDT_R, tools::md5sum(file.path(root_dir, "src", "diffusion.cpp"))), fig.width=8}

theta <- filter(Y, diff == max(diff)) %>%
  slice(1) %>%
  select(a, v, t0, z, sz, sv, st0)

kable(theta,format = "html", digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE)

theta <- unlist(theta)

A <- as.data.frame(diffusion_SDT(1e6, a = theta["a"], z = theta['z'],
                                 v = theta["v"], sv = theta["sv"],
                                 t0 = theta["t0"], st0 = theta["st0"]
                                 )
                   ) %>%
  select(rt = RT, response = speeded_resp)

B <- rdiffusion(1e6, a = theta["a"], z = theta['z'],
                v = theta["v"], sv = theta["sv"],
                t0 = theta["t0"], st0 = theta["st0"]
                ) %>%
  mutate(response = as.numeric(response) - 1)

rt_distributions2 <- bind_rows("diffusion_SDT" = A,
                               "rdiffusion" = B,
                               .id = "type") %>%
  filter(rt <= quantile(rt, .999))

ggplot(rt_distributions2, aes(x=rt,color=type)) +
  geom_density() +
  facet_grid(~response, labeller = label_both) +
  theme(legend.position = "top")

```

```{r quantile_difference, echo=FALSE}
q_sim_0 <- quantile(filter(A, response==0)$rt, .1)
q_rtdists_0<- quantile(filter(B, response==0)$rt, .1)

q_sim_1 <- quantile(filter(A, response==1)$rt, .1)
q_rtdists_1<- quantile(filter(B, response==1)$rt, .1)
```


We can see that for both the "best" and "worst", the distribution produced by the `diffusion_SDT` simulation method is right-shifted relative to the `rdiffusion` implementation, though the shift is more pronounced for the "worst" parameter set.

## Counts vs. Parameters
To try to understand why these two groups of implementations produce comparable, but not precisely similar results, we will try to relate the sampled parameter values to "error" between the `diffusion_SDT` function and the `rdiffusion` function.

We'll focus on differences in the first decile, since the differences are most pronounced there. The scatter plots below show "error" associated with each sampled parameter value.

```{r differences_plot, echo=FALSE, fig.width=9, fig.height=9}
Z <- gather(Y, key="parameter", value="value", -id, -diff, -response)

ggplot(filter(Z, response==0), aes(x=value, y=diff)) +
  geom_point() +
  ylab("True - diffusion_SDT counts") +
  facet_wrap(~parameter, scales="free") +
  ggtitle("Lower Boundary Responses")

ggplot(filter(Z, response==1), aes(x=value, y=diff)) +
  geom_point()+
  ylab("True - diffusion_SDT counts") +
  facet_wrap(~parameter, scales="free") +
  ggtitle("Upper Boundary Responses")
```

These plots show that the degree of "error" between the two implementation depends on the value of the Z parameter, which controls the starting point of the evidence accumulation process. This relationship is most apparent for lower boundary, or "0" responses. When the Z parameter is closer to the lower boundary than the upper, the degree of error is very high.

Thus, it appears that the `diffusion_SDT` simulation is "too noisy" relative to the `rdiffusion` simulation - the accumulator is not hitting the response boundary a quickly as it should, especially when it begins very close to a boundary. 

However, it should be noted that despite large differences in counts, the value of the RT quantiles between these two methods are not very different. For example, using the "worst" set off parameters from earlier, the difference between the RT cutoff value for the first decile of lower boundary responses was `r round(abs(q_rtdists_0 - q_sim_0)*1000, 3)` milliseconds, and the difference between the RT cutoff value for the first decile of upper boundary responses was `r round(abs(q_rtdists_1 - q_sim_1)*1000, 3)` milliseconds


## Improvements
Using a smaller time step size (1/10 of a millisecond instead of 1 millisecond) for the `diffusion_SDT` and `diffusion_SDT_R` reduces the "error" between these implementations and the `rtdists` reference implementation, but does not eliminate it.

However, it is unclear if this is the "real" solution. It may be that this change helps "mask" an error in the `diffusion_SDT` and `diffusion_SDT_R` simulation implementations. Reducing time step size by a factor of 10 also slows the simulations by a factor of 10.

## Session Info


```{r}
sessionInfo()
```

