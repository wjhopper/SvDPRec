---
title: "Diffusion Modeling"
author: "William Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(kableExtra)
library(optimx)
library(foreach)
library(rtdists)
library(ggplot2)
library(dplyr)
library(tidyr)

root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{css }
.main-container {
    max-width: 1200px;
}
```

```{r diffusion_functions, cache=TRUE}
diffusion_obj <- function(parameters, data, fixed=NULL, scale=FALSE){

  parameters <- c(parameters, fixed)
  if (scale) {
    parameters['v.W'] <- parameters['v.L'] + parameters['v.W']*parameters['sv.L']
    parameters['v.S'] <- parameters['v.L'] + parameters['v.S']*parameters['sv.L']
    parameters['sv.T'] <- parameters['sv.T']*parameters['sv.L']
  }
  log_likelihood <- 0

  all_strengths <- unique(data$strength) # Conditions to loop over
  boundaries <- 1:2 # Boundaries to loop over
  
  for (strength in all_strengths) {

    condition_index <- data$strength==strength
    bin_counts <- data$bin_counts[condition_index]
    p <- numeric(sum(condition_index))
    
    if (strength == "L") {
      sv = parameters["sv.L"]
    } else {
      sv = parameters["sv.T"]
    }

    insert_at = 0
    for (b in boundaries) {

      i <- condition_index & data$boundary == b
      cutpoints <- data$value[i]
      cutpoints[length(cutpoints)] <- Inf

      p_b <- pdiffusion(rt = cutpoints, response = b,
                        a = parameters["a"],
                        z = parameters["a"] * parameters["z"],
                        t0 = parameters["t0"],
                        st0 = parameters["st0"],
                        v = parameters[paste0("v.", strength)],
                        sv = sv)

      p_b <- c(p_b[1], diff(p_b))
      less <- p_b <= 0
      if (any(less)) {
        p_b[less] <- 0.0001
        p_b <- p_b/sum(p_b)
      }

      p[(insert_at+1):(insert_at+length(p_b))] <- p_b
      insert_at <- insert_at + length(p_b)
    }

    log_likelihood <- log_likelihood + dmultinom(x = bin_counts,
                                                 size = sum(bin_counts),
                                                 prob = p,
                                                 log = TRUE)
    if (is.infinite(log_likelihood)) {
      return(1e9)
    }
  }

  return(-log_likelihood)

}
```

```{r load_data}
load(file.path(root_dir, "data", "SvDPRec.Rdata"))
test <- select(test, -list)
```

```{r observed_RT_choice_data}
speeded_RT_choice_quantiles <- filter(test, !is.na(type)) %>%
  filter(speeded_RT > 200) %>%
  mutate(speeded_RT = speeded_RT/1000) %>%
  group_by(subject, strength, speeded_judgment) %>%
  summarise(quintiles = list(
              data.frame(quantile = c("10%", "30%", "50%", "70%", "90%", "100%"),
                         value = quantile(speeded_RT, c(.1, .3, .5, .7, .9, 1)),
                         bin_counts = floor(n() * c(.1, .2, .2, .2, .2, .1)),
                         stringsAsFactors = FALSE)
              )) %>%
  ungroup() %>%
  unnest()

speeded_acc <- filter(test, !is.na(type)) %>%
  group_by(subject, strength) %>%
  summarise(acc = mean(speeded_correct))
```

```{r start_cluster}
cl <- parallel::makeCluster(parallel::detectCores(),
                            outfile = "",
                            methods = FALSE)

doParallel::registerDoParallel(cl)
```

```{r fit, cache=TRUE, dependson=c("diffusion_functions")}

# a = boundary separation
# z = starting point (parameterized here as a proportion of boundary separation)
# t0 = lower bound of non-decision RT component
# st0 = range of uniform distribution of non-decision times. NDT distribution is U(t0, t0+st0)
# v.L = drift rate for Lures (fixed at 1)
# v.W = drift rate for weak targets
# v.S = drift rate for strong targets
# sv.L = inter-trial drift variance for lures
# cv.T = inter-trial drift variance for targets (both weak and strong)

diffusion_fits <- foreach(sub = split(speeded_RT_choice_quantiles, speeded_RT_choice_quantiles$subject),
                          .packages = c("rtdists","optimx")) %dopar% {

    # Make incorrects the lower boundary responses (1) and corrects the upper boundary responses( 2)
    # This will be useful inside the objective function
    sub$boundary <- as.numeric(factor(sub$speeded_judgment,
                                      levels = c('n','o'),
                                      labels = c("lower",'upper')
                                      )
                               )
    fit <- optimx(par = c("a"= 1, "z"=.5, "t0"=.1, "st0"=.1,
                          "v.L"=0, "v.W"=.5, "v.S"=1,
                          "sv.L"=.5, "sv.T" = .75
                          ),
                  fn = diffusion_obj,
                  method = c("L-BFGS-B"), 
                  itnmax = 3000,
                  lower = c(0.01, .05, .01,  .01, -5, -5, -5, 0.1, 0.1),
                  upper = c(3,    .95, .5,   .5,   5,  5,  5, 4,   4),
                  control = list(kkt=FALSE, follow.on=TRUE),
                  data = sub)
    fit$subject <- sub$subject[1]
    fit
  }

```

```{r fit_fixed_drifts, cache=TRUE, cache.extra = tools::md5sum(file.path(root_dir, "vignette","SDTparams.csv"))}
fixed_SDT_params <- read.csv(file.path(root_dir, "vignette","SDTparams.csv")) %>%
  mutate(subject = subject + 100) %>%
  select(subject, v.W = Weak, v.S = Strong, sv.T = sigma)

fixed_drifts_fits <- foreach(sub = split(speeded_RT_choice_quantiles, speeded_RT_choice_quantiles$subject),
                          .packages = c("rtdists","optimx")) %dopar% {

    # Make incorrects the lower boundary responses (1) and corrects the upper boundary responses( 2)
    # This will be useful inside the objective function
    sub$boundary <- as.numeric(factor(sub$speeded_judgment,
                                      levels = c('n','o'),
                                      labels = c("lower",'upper')
                                      )
                               )
    fixed_p <- unlist(fixed_SDT_params[fixed_SDT_params$subject == sub$subject[1], 2:4])
    
    fit <- optimx(par = c("a"= 1, "z"=.5, "t0"=.1, "st0"=.1,
                          "v.L"=0, "sv.L"=.5),
                  fn = diffusion_obj,
                  method = c("L-BFGS-B"), 
                  itnmax = 3000,
                  lower = c(0.01, .05, .01, .01, -5, 0.1),
                  upper = c(3,    .95, .5,  .5,   5, 4),
                  control = list(kkt=FALSE, follow.on=TRUE),
                  data = sub,
                  fixed = fixed_p,
                  scale = TRUE)
    fit$subject <- sub$subject[1]
    fit[names(fixed_p)] <- as.list(fixed_p)
    fit
  }
```

```{r stop_cluster}
parallel::stopCluster(cl)
```

```{r tidy_parameters}
diffusion_fits <- bind_rows(drift_free = bind_rows(diffusion_fits),
                            drift_fixed =  bind_rows(fixed_drifts_fits),
                            .id = "model")

V <- select(diffusion_fits, subject, model, v.L, v.W, v.S) %>%
  gather("parameter","value", v.L, v.W, v.S) %>%
  mutate(strength = sub("v.", "", parameter, fixed=TRUE)) %>%
  select(subject, model, strength, v = value)

SV <- select(diffusion_fits, subject, model, sv.L, sv.T) %>%
  rename(sv.W = sv.T) %>%
  mutate(sv.S = sv.W) %>%
  gather("parameter","value", sv.L, sv.W, sv.S) %>%
  mutate(strength = sub("sv.", "", parameter, fixed=TRUE)) %>%
  select(subject, model, strength, sv = value)

tidy_params <- select(diffusion_fits, subject, model, a, z, t0, st0) %>%
  left_join(x = distinct(speeded_RT_choice_quantiles, subject, strength),
            y = .,
            by = "subject") %>%
  left_join(y = V,
            by = c("subject","strength","model")) %>%
  left_join(y = SV,
            by = c("subject","strength","model"))
```

```{r predictions, cache=TRUE, dependson=c("fit_fixed_drifts","fit")}
pred_acc <- rowwise(tidy_params) %>%
  mutate(pOld = pdiffusion(rt = Inf, response = 2,
                           a = a, z = z*a, t0 = t0, st0 = st0,
                           v = v, sv = sv),
         acc = replace(pOld, strength == "L", 1 - pOld[strength == "L"]))
accuracy <- bind_rows(predicted = select(pred_acc, subject, model, strength, acc),
                      observed = mutate(speeded_acc, model = 'observed')
                      )

pred_RT_quantiles <- rowwise(tidy_params) %>%
  mutate(RT = list(as.data.frame(matrix(
                qdiffusion(p = rep(c(.1, .3, .5, .7, .9), 2),
                           response = rep(1:2, each = 5),
                           a = a, z = z*a, t0 = t0, st0 = st0,
                           v = v, sv = sv,
                           scale_p = TRUE),
                nrow=2, ncol=5,
                byrow=TRUE,
                dimnames = list(c("Incorrect","Correct"),
                                quantile = c("10%","30%", "50%", "70%", "90%"))
                )))
         ) %>%
  unnest() %>% 
  mutate(speeded_judgment = rep(c('n', 'o'), nrow(.)/2)) %>%
  select(subject, model, strength, speeded_judgment, `10%`, `30%`, `50%`, `70%`, `90%`) %>%
  gather('quantile', 'value', `10%`, `30%`, `50%`, `70%`, `90%`)

RT_quantiles <- bind_rows(predicted = pred_RT_quantiles,
                          observed = filter(speeded_RT_choice_quantiles, quantile != "100%") %>%
                                      select(-bin_counts) %>%
                                      mutate(model = 'observed')
                          ) %>%
  mutate(speeded_correct = ifelse((strength == "L" & speeded_judgment == "n") |
                                    strength %in% c("S", "W") & speeded_judgment == "o",
                                  TRUE,
                                  FALSE)
         )
```

```{r plots, fig.width=11, fig.align="center", results="asis"}

formatted_names <- c(
                     "V<sub>L</sub>", "V<sub>W</sub>", "V<sub>S</sub>",
                     "S<sub>vL</sub>", "S<sub>vT</sub>",
                     "a", "z", "t<sub>0</sub>", "s<sub>t0</sub>",
                     "-LL", "Conv. Code")
model_name_key <- c("observed" = "Observed",
                    "drift_free" = "Free V",
                    "drift_fixed" = "Fixed V")

for (s in unique(speeded_RT_choice_quantiles$subject)) {
  
  cat(sprintf("<h3>Subject %s</h3>", s))
  
  subject_params <- filter(diffusion_fits, subject == s)
  rownames(subject_params) <- model_name_key[subject_params$model]
  
  kable(select(subject_params, v.L, v.W, v.S, sv.L, sv.T, a, z, t0, st0, value, convcode),
        digits = 3,
        col.names = formatted_names,
        row.names = TRUE,
        escape = FALSE
        ) %>%
    kableExtra::kable_styling(full_width = FALSE) %>%
    print()

  acc_plot <-
    ggplot(filter(accuracy, subject == s),
          aes(x=strength, y=acc, shape=model, color=strength)) +
    geom_point(size=2,stroke=2, position = position_dodge(.5)) +
    scale_shape_manual("",
                       values = c(16,4,8),
                       limits = c("observed","drift_free","drift_fixed"),
                       labels = c("Observed", "Free v", "Fixed v")) +
    scale_color_discrete(labels = c("L" = "Lure",
                                    "W" = "Weak\nTarget",
                                    "S" = "Strong\nTarget"),
                         breaks = c("L","W","S")) +
    scale_y_continuous("Percent Correct", limits = c(0, 1)) +
    scale_x_discrete(labels = c("L" = "Lure",
                                "W" = "Weak\nTarget",
                                "S" = "Strong\nTarget"),
                     limits = c("L","W","S"),
                     expand = c(0, .2)) +
    theme(legend.key.height = unit(9, 'mm'))
  
  quantile_plot <- 
    ggplot(filter(RT_quantiles, subject == s),
           aes(x=quantile, y=value, shape=model, color=strength)) +
    geom_point(size=2) +
    geom_line(aes(group=model)) +
    facet_grid(speeded_correct ~ strength,
               labeller = labeller(speeded_correct = as_labeller(
                                    c("TRUE" = "Correct",
                                      "FALSE" = "Error")
                                    ),
                                    strength = as_labeller(
                                      c("L" = "Lure",
                                        "S" = "Strong Target",
                                        "W" = "Weak Target")
                                    )
                                   )
               ) +
    scale_shape_manual("",
                       values = c(16,4,8),
                       limits = c("observed","drift_free","drift_fixed"),
                       labels = c("Observed", "Free \u03BD", "Fixed \u03BD")) +
    scale_y_continuous("RT Quantile Value (s.)") +
    guides(color=FALSE, shape=FALSE)
  
  gridExtra::grid.arrange(acc_plot, quantile_plot, nrow=1,
                          widths=c(.35, .65))
}
```