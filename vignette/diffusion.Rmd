---
title: "2HT Modeling"
author: "William Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(kableExtra)
library(optimx)
library(foreach)
library(ggplot2)
library(dplyr)
library(tidyr)
root_dir <- rprojroot::is_rstudio_project$find_file()
```


```{r diffusion_functions, cache=TRUE}
diffusion_obj <- function(parameters, data, fixed=NULL, scale=FALSE){

  parameters <- c(parameters, fixed)
  if (scale) {
    parameters['v.W'] <- parameters['v.L'] + parameters['v.W']*parameters['sv.L']
    parameters['v.S'] <- parameters['v.L'] + parameters['v.S']*parameters['sv.L']
    parameters['sv.T'] <- parameters['sv.T']*parameters['sv.L']
  }
  log_likelihood <- 0

  for (strength in unique(data$strength)) {

    condition_index <- data$strength==strength
    
    if (strength == "L") {
      sv = parameters["sv.L"]
    } else {
      sv = parameters["sv.T"]
    }

    for (acc in unique(data$speeded_correct)) {

      i <- data$strength==strength & data$speeded_correct == acc 
      cutpoints <- c(0, data$value[i])
      cutpoints[length(cutpoints)] <- Inf

      p <- pdiffusion(rt = cutpoints, response = acc,
                      a = parameters["a"],
                      z = parameters["a"] * parameters["z"],
                      t0 = parameters["t0"],
                      st0 = parameters["st0"],
                      v = parameters[paste0("v.", strength)],
                      sv = sv)
      p <- diff(p)
      p[p<0] <- 0
      bin_counts <- data$bin_counts[i]
      log_likelihood <- log_likelihood + dmultinom(x = bin_counts,
                                                   size = sum(bin_counts),
                                                   prob = p/sum(p),
                                                   log = TRUE)
    }
  }
  
  if (is.infinite(log_likelihood)) {
    return(.Machine$double.xmax)
  } else {
    return(-log_likelihood)
  }
  
}
```

```{r load_data}
load(file.path(root_dir, "data", "SvDPRec.Rdata"))
test <- select(test, -list)
```

```{r observed_RT_choice_data}
speeded_RT_choice_quantiles <- filter(test, !is.na(type)) %>%
  mutate(speeded_RT = speeded_RT/1000) %>%
  group_by(subject, strength, speeded_correct) %>%
  summarise(quintiles = list(
              data.frame(quantile = c("10%", "30%", "50%", "70%", "90%", "100%"),
                         value = quantile(speeded_RT, c(.1, .3, .5, .7, .9, 1)),
                         bin_counts = floor(n() * c(.1, .2, .2, .2, .2, .1))
                         )
              )) %>%
  ungroup() %>%
  unnest()
```

```{r fit, cache=TRUE, dependson=c("diffusion_functions")}

# a = boundary separation
# z = starting point (parameterized here as a proportion of boundary separation)
# t0 = lower bound of non-decision RT component
# st0 = range of uniform distribution of non-decision times. NDT distribution is U(t0, t0+st0)
# v.L = drift rate for Lures (fixed at 1)
# v.W = drift rate for weak targets
# v.S = drift rate for strong targets
# sv.L = inter-trial drift variance for lures
# cv.T = inter-trial drift variance for targets (both weak and strong)
doParallel::registerDoParallel(cores = parallel::detectCores())
diffusion_fits <- foreach(sub = split(speeded_RT_choice_quantiles, speeded_RT_choice_quantiles$subject),
                          .packages = c("rtdists","optimx")) %dopar% {

    # Make incorrects the lower boundary responses (1) and corrects the upper boundary responses( 2)
    # This will be useful inside the objective function
    sub$speeded_correct <- sub$speeded_correct + 1
    fit <- optimx(par = c("a"= 1, "z"=.5, "t0"=.25, "st0"=.1,
                          "v.L"=.5, "v.W"=.5, "v.S"=1,
                          "sv.L"=.5, "sv.T" = .75
                          ),
                  fn = diffusion_obj,
                  method = c("nlminb"), 
                  itnmax = 3000,
                  lower = c(.001, .001, .001,  .001, -Inf, -Inf, -Inf, .001, .001),
                  upper = c(Inf,    1,   Inf,   Inf,   Inf,  Inf,  Inf, Inf,  Inf),
                  control = list(kkt=FALSE, follow.on=TRUE),
                  data = sub)
    fit$subject <- sub$subject[1]
    fit
  }

```