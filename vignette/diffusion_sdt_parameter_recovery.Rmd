---
title: "Diffusion SDT Parameter Recovery"
author: "Will Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(Rcpp)
library(kableExtra)
library(optimx)
library(foreach)
library(rtdists)
library(ggplot2)
library(dplyr)
library(tidyr)
library(RcppParallel)
library(dqrng)
library(iterators)
root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{r diffusion}
libdir <- file.path(root_dir, "src", "libs")
if (!dir.exists(libdir)) {
  dir.create(libdir)
}
sourceCpp(file.path(root_dir, "src", "diffusion.cpp"),
          cacheDir = libdir)

diffusion_datasets <- function(N=500) {
  set.seed(42)
  parameters <- data.frame(a = runif(N, .5, 1.5),
                           v = rnorm(N),
                           sv = rexp(N, 2),
                           t0 = runif(N, 0, .5),
                           st0 = runif(N, 0, .25),
                           z = runif(N),
                           sz = runif(N, 0, .5),
                           crit_old = runif(N, -1,0),
                           crit_new = runif(N, 0, 1)
             ) %>%
    tibble::rowid_to_column("id")
  
    quantile_summary <- do(rowwise(parameters), {
      row = .$id
      sim_data <- as.data.frame(
        diffusion_SDT(5e4, a=.$a,v=.$v, t0=.$t0, z=.$z, sz=.$sz, sv=.$sv, st0=.$st0,
                      crit = c(.$crit_old, .$crit_new)
                      )
          ) %>%
        group_by(speeded_resp)
      
      speeded_quantiles <- sim_data %>%
        summarise(quintiles = list(
                  data.frame(quantile = c("10%", "30%", "50%", "70%", "90%", "100%"),
                             value = quantile(RT, c(.1, .3, .5, .7, .9, 1)),
                             stringsAsFactors = FALSE)
                  )) %>%
        ungroup()

      joint_counts <- sim_data %>%
        group_by(delayed_resp, add=TRUE) %>%
        count() %>%
        ungroup() %>%
        left_join(speeded_quantiles, by = "speeded_resp") %>%
        ungroup() %>%
        filter(n >= 6) %>%
        unnest() %>%
        group_by(speeded_resp, delayed_resp) %>%
        mutate(bin_counts = ceiling(n*c(.1, .2, .2, .2, .2, .1))) %>%
        ungroup() %>%
        mutate(id = row) %>%
        select(id, speeded_resp, delayed_resp, quantile, value, bin_counts)
    }) %>%
    tidyr::nest(-id)

  return(bind_cols(select(parameters, -id),
                   quantile_summary
                   )
         )
}

diffusion_obj <- function(theta, data, fixed=NULL, scale=FALSE){

  theta <- c(theta, fixed)
  Nsim <- 5e4
  boundaries <- c(0,1) # Boundaries to loop over

  sim_data <- diffusion_SDT(N=Nsim, a = theta["a"], z = theta['z'],
                            v = theta["v"], sv = theta["sv"],
                            t0 = theta["t0"], st0 = theta["st0"],
                            crit = theta[c("crit_old","crit_new")],
                            )

  p <- numeric(nrow(data))
  insert_at = 1

  for (sp_resp in boundaries) {
    for (del_resp in boundaries) {

      resp_index <- data$speeded_resp == sp_resp &
                    data$delayed_resp == del_resp
      # Only proceed if this isn't a missing cell
      if (any(resp_index)) {
        matching_sim_responses <- sim_data[,'speeded_resp'] == sp_resp &
                                  sim_data[,'delayed_resp'] == del_resp
        cutpoints <- data$value[resp_index]
        cutpoints[length(cutpoints)] <- Inf
        
        for (i in 1:length(cutpoints)) {
          rt <- cutpoints[i]
          p_cut <- sum(sim_data[matching_sim_responses, 'RT'] <= rt)
          p[insert_at] <- p_cut
          insert_at <- insert_at + 1
        }
        first <- insert_at-length(cutpoints)
        last <- insert_at - 1
        p[first:last] <- c(p[first], diff(p[first:last]))
      }
    }
  }

  if (any(p==0)) {
    return(1e9)
  }

  log_likelihood <- dmultinom(x = data$bin_counts,
                              size = sum(data$bin_counts),
                              prob = p / Nsim,
                              log = TRUE)

  return(-log_likelihood)
}
```

```{r data, cache=TRUE, dependson=c("diffusion_functions")}
datasets <- diffusion_datasets()
```


```{r fit, cache=TRUE, dependson=c("diffusion_functions")}
RcppParallel::setThreadOptions(parallel::detectCores())

p_names <- c("v", "sv", "a", "t0", "st0", "z", "sz", "crit_old", "crit_new")

diffusion_fits <- foreach(d = iter(datasets,by="row")) %do% {

    # Extract & order paramter vector for optimization

    parameters <- numeric(length(p_names))
    names(parameters) <- p_names

    best_value <- Inf
    n <- 1
    while (n <= 100) {

      print(sprintf("Dataset %d, iteration %i", d$id[1], n))
      parameters["v"] <- rnorm(1, 0, 2)
      parameters["sv"] <- rexp(1, 2)
      parameters["a"] <- runif(1, 0, 1.5)
      parameters["t0"] <- runif(1, 0, .5)
      parameters["st0"] <- runif(1, 0, .25)
      parameters["z"] <- runif(1)
      parameters["sz"] <- runif(1, 0, .5)
      parameters["crit_old"] <- runif(1, -1, 0)
      parameters["crit_new"] <- runif(1, 0, 1)

      fit <- optimx(parameters,
                    fn = diffusion_obj,
                    method = c("L-BFGS-B"),
                    itnmax = 1000,
                    lower = c(-6, 0, 0, 0,   0,   0,    0,  -4, -4),
                    upper = c( 6, 5, 4, .75, .75, .99, .75,  4,  4),
                    control = list(kkt=FALSE, maxit=1000),
                    data = d$data[[1]]
                    )
      if (fit$value < best_value) {
        best_value <- fit$value
        best_fit <- fit
      }
      value <- fit$value
      n <- n + 1
    }

    # If we never improved, just take the last one, it doesn't matter anyway,
    # we just need an object to save
    if (best_value == Inf) {
      best_fit <- fit 
    }

    best_fit
  }

diffusion_fits <- lapply(diffusion_fits, tibble::rownames_to_column, var="method") %>%
  bind_rows()
GOF <- select(diffusion_fits, subject, fevals, gevals, niter, convcode, value)
bf_parameters <- select(diffusion_fits, !!!names(p_names))
```

```{r}
x <- bind_rows(real = select(datasets, !!!names(p_names), id),
               est = tibble::rowid_to_column(bf_parameters, var = "id"),
               .id="type") %>%
  gather(key="parameter",value = "value", -rowid, -type) %>%
  spread(key="type",value="value")
```

