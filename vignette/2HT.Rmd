---
title: "2HT Modeling"
author: "William Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---
```{css css, echo=FALSE}
.main-container {
    max-width: 1100px;
  }
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", cache=TRUE)
library(rprojroot)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(optimx)
library(foreach)
library(rstan)
library(tidybayes)
library(ggplot2)
library(MPTinR)
library(doParallel)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{r load_data}
load(file.path(root_dir, "data","SvDPRec.Rdata"))
test <- select(test, -list)
```

```{r cell_counts, dependson="load_data"}
delayed_counts_by_sub_bias <- filter(test, !is.na(type)) %>%
  select(-starts_with("speeded")) %>%
  rename(correct = delayed_correct) %>%
  count(subject, strength, pOld, correct) %>%
  complete(subject, strength, pOld, correct,
           fill = list(n=0)) %>%
  unite(col = "resp_type", strength, correct) %>%
  spread(resp_type, n) %>%
  rename(FA = L_FALSE, CR = L_TRUE,
         M_S = S_FALSE, H_S = S_TRUE,
         M_W = W_FALSE, H_W = W_TRUE) %>%
  mutate(L_N = FA + CR,
         S_N = M_S + H_S,
         W_N = M_W + H_W) %>%
  select(subject, pOld, FA, L_N, H_S, S_N, H_W, W_N)

```

```{r empirical_roc_data, dependson="cell_counts"}
obs_ROC_data <- mutate(delayed_counts_by_sub_bias,
                       FAR = FA/L_N,
                       HR_W = H_W/W_N,
                       HR_S = H_S/S_N,
                       pOld = sprintf("%2.0f%%", pOld*100)) %>%
  select(subject, pOld, FAR, HR_W, HR_S) %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  select(subject, pOld, strength, FAR, HR)

avg_obs_ROC_data <- group_by(obs_ROC_data, pOld, strength) %>%
  summarise_at(.vars = c("FAR", "HR"), .funs = "mean") %>%
  ungroup()
```

```{r null_LL, dependson=c("cell_counts")}
null_LL <- mutate(delayed_counts_by_sub_bias,
                  FA_LL = dbinom(FA, L_N, FA / L_N, log = TRUE),
                  HW_LL = dbinom(H_W, W_N, H_W / W_N, log = TRUE),
                  HS_LL = dbinom(H_S, S_N, H_S / S_N, log = TRUE),
                  LL = FA_LL + HW_LL + HS_LL) %>% 
  select(subject, pOld, LL) %>%
  group_by(subject) %>%
  summarise(null_LL = sum(LL))
```

## Hierarchical Bayesian Estimation
### Will's Stan Model
```{stan stan_model_external, cache=FALSE, eval=FALSE, echo=TRUE, output.var='modelstring', code=readLines(file.path(root_dir, "R","2HT.stan"))}
```

```{r stan_model, results="hide", dependson="cell_counts", cache.extra = tools::md5sum(file.path(root_dir, "R","2HT.stan"))}
# Create an array suitable for passing into stan, so it can be turned into an array of matrices
# The final produce should be 14 x 3 x 3, with subject along dim 1, bias level (conservative --> liberal) along dim 2,
# and strength (lure, weak, strong) along dim 3.
corrects_matrix <- arrange(delayed_counts_by_sub_bias, subject, desc(pOld)) %>%
  mutate(CR = L_N - FA,
         H_S = replace(H_S, H_S == S_N, H_S[H_S == S_N]-1)) %>%
  as.matrix(x=.[,c('CR','H_W','H_S')], rownames.force = FALSE) %>%
  t()
dim(corrects_matrix) <- c(3, 3, 14)
dimnames(corrects_matrix) <- list("Strength" = c("Lure","Weak","Strong"),
                                  "Bias" = c("Lib.", "Neutral", "Cons."),
                                  "Subject" = 101:114)
corrects_matrix <- aperm(corrects_matrix, c(2,1,3))

trial_matrix <- arrange(delayed_counts_by_sub_bias, subject, desc(pOld)) %>%
  mutate(CR = L_N - FA,
         H_S = replace(H_S, H_S == S_N, H_S[H_S == S_N]-1)) %>%
  as.matrix(x=.[,c('L_N','W_N','S_N')], rownames.force = FALSE) %>%
  t()
dim(trial_matrix) <- c(3, 3, 14)
dimnames(trial_matrix) <- list("Strength" = c("Lure","Weak","Strong"),
                               "Bias" = c("Lib.","Neutral","Cons."),
                               "Subject" = 101:114)
trial_matrix <- aperm(trial_matrix, c(2,1,3))

standata <- list(corrects = corrects_matrix, trials = trial_matrix,
                 Nsubs = length(unique(delayed_counts_by_sub_bias$subject)))

twoHT_stan_fit <- stan(file = file.path(root_dir, "R","2HT.stan"),
                       data = standata,
                       iter = 3000,
                       chains = 4,
                       seed = 1235,
                       init_r = 1,
                       control = list(adapt_delta = .99, max_treedepth = 15)
                       )
twoHT_stan_fit <- recover_types(twoHT_stan_fit)
rm(corrects_matrix, trial_matrix, standata)
```

```{r stan_parameter_summaries, dependson="stan_model"}
twoHT_stan_subject_params <- spread_draws(twoHT_stan_fit, `GO_.*`[subject], `D.*`[subject], regex=TRUE) %>%
  ungroup() %>%
  mutate(subject = as.character(subject + 100)) %>%
  group_by(subject)

twoHT_stan_subject_param_summaries <- mean_hdi(twoHT_stan_subject_params)
  
twoHT_stan_pop_params <- spread_draws(twoHT_stan_fit, `beta_.*`[parameter_index], regex=TRUE)

param_index_key <- c("DN", "DO_W", "DO_S", "GO_Lib", "GO_Neut", "GO_Cons")
twoHT_stan_pop_param_summaries <- mean_hdi(twoHT_stan_pop_params) %>%
  select(-.point, -.interval, -.width) %>%
  mutate(parameter_index = param_index_key[parameter_index]) %>%
  gather("param", "value", -parameter_index) %>%
  mutate(param = sub("beta_", "", param)) %>%
  unite(col=param, parameter_index, param) %>%
  spread(param, value)

rm(param_index_key)
```

```{r stan_ROC_point_predictions, dependson="stan_model"}
detect_params <- select(twoHT_stan_subject_param_summaries, subject, DN, DO_W, DO_S) %>%
  gather("strength","detect_prob", -subject) %>%
  mutate(strength = recode(strength, DN = "L", DO_W = "W", DO_S = "S"))

bias_params <- select(twoHT_stan_subject_param_summaries, subject, GO_Lib, GO_Neut, GO_Cons) %>%
  gather("pOld","guess_old_prob", -subject) %>%
  mutate(pOld = recode(pOld, GO_Lib = "75%", GO_Neut = "50%", GO_Cons = "25%"))

twoHT_stan_pred_accuracy <- full_join(detect_params, bias_params, by="subject") %>%
  select(subject, strength, pOld, detect_prob, guess_old_prob) %>%
  arrange(subject,strength, pOld) %>%
  mutate(guess_correct_prob = ifelse(strength=="L", 1-guess_old_prob, guess_old_prob),
         pCorrect = detect_prob + (1-detect_prob)*(guess_correct_prob)) %>%
  select(-guess_old_prob)

twoHT_stan_ROC_data <- select(twoHT_stan_pred_accuracy, -detect_prob, -guess_correct_prob) %>%
  spread(strength, pCorrect) %>%
  mutate(FAR = 1-L) %>%
  select(subject, pOld, FAR, HR_W = W, HR_S = S) %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  select(subject, pOld, strength, FAR, HR) %>%
  bind_rows(pred = ., obs = obs_ROC_data, .id = "type") %>%
  arrange(subject, pOld, strength, type)

rm(detect_params, bias_params)
```


```{r ROC_plot, results="asis", dependson="stan_model"}
for (s in unique(twoHT_stan_ROC_data$subject)) {
  
  cat(sprintf("<h3>Subject %s</h3>", s))
  
  filter(twoHT_stan_subject_param_summaries, subject == s) %>%
    select(-.width, -.interval, -.point) %>%
    gather("param", "value", -subject) %>%
    separate(param, into = c("param","stat"), sep = "\\.",
             fill="right") %>%
    spread(stat, value) %>%
    select(param, mean = `<NA>`, lower, upper) %>%
    mutate(lower = round(lower, 3),
           upper = round(upper, 3),
           HDI = paste("[", lower, ", ", upper, "]", sep="")
           ) %>%
    select(param, mean, HDI) %>%
    knitr::kable(digits=3,
                 type="html",
                 col.names = c("Parameter", "Posterior Mean", "HDI")) %>%
    kable_styling(full_width = FALSE, position = "float_left") %>%
    column_spec(1, bold=TRUE) %>%
    print()
  
    ROC <- ggplot(filter(twoHT_stan_ROC_data, subject == s),
                  aes(x=FAR, y=HR, linetype=type, shape=pOld)) +
      geom_point(size=2) +
      geom_line(aes(group=type), size=.8) +
      facet_grid(~strength) +
      scale_x_continuous(limits = c(0, 1)) +
      scale_y_continuous(limits = c(0, 1)) +
      coord_equal()
    print(ROC)
}

rm(ROC, s)
```

## MLE Version

### MPT 

```{r 2HT_model_and_data, dependson=c("cell_counts")}
twoHT_mpt_model <- "
# Tree for strong items in pOld=25% condition. First 'old', then 'new'
dS + (1-dS) * gC
(1-dS)*(1-gC)

# Tree for weak items in pOld=25% condition. First 'old', then 'new'
dW + (1-dW) * gC
(1-dW)*(1-gC)

#Tree for lures in pOld=25% condition. First 'old', then 'new'
(1-dN) * gC
dN + (1-dN) * (1 - gC)

# Tree for strong items in pOld=50% condition. First 'old', then 'new'
dS + (1-dS) * gN
(1-dS)*(1-gN)

# Tree for weak items in pOld=50% condition. First 'old', then 'new'
dW + (1-dW) * gN
(1-dW)*(1-gN)

#Tree for lures in pOld=50% condition. First 'old', then 'new'
(1-dN) * gN
dN + (1-dN) * (1 - gN)

# Tree for strong items in pOld=75% condition. First 'old', then 'new'
dS + (1-dS) * gL
(1-dS)*(1-gL)

# Tree for weak items in pOld=75% condition. First 'old', then 'new'
dW + (1-dW) * gL
(1-dW)*(1-gL)

#Tree for lures in pOld=75% condition. First 'old', then 'new'
(1-dN) * gL
dN + (1-dN) * (1 - gL)
"

twoHT_mpt_data_layout <- transmute(delayed_counts_by_sub_bias,
  subject,
  pOld,
  strong_old = H_S,
  strong_new = S_N - H_S,
  weak_old = H_W,
  weak_new = W_N - H_W,
  lure_old = FA,
  lure_new = L_N - FA) %>%
  gather("response","count", -subject, -pOld) %>%
  unite(condition, pOld, response) %>%
  spread(condition, count) %>%
  select(subject,
         `0.25_strong_old`, `0.25_strong_new`,
         `0.25_weak_old`, `0.25_weak_new`,
         `0.25_lure_old`, `0.25_lure_new`,
         `0.5_strong_old`, `0.5_strong_new`,
         `0.5_weak_old`, `0.5_weak_new`,
         `0.5_lure_old`, `0.5_lure_new`,
         `0.75_strong_old`, `0.75_strong_new`,
         `0.75_weak_old`, `0.75_weak_new`,
         `0.75_lure_old`, `0.75_lure_new`) %>%
  as.data.frame() %>%
  tibble::column_to_rownames("subject") %>%
  data.matrix()
```

```{r 2HT_fit, dependson="2HT_model_and_data"}
twoHT_mpt_fit <- fit.mpt(data = twoHT_mpt_data_layout,
                         model.filename = textConnection(twoHT_mpt_model),
                         show.messages = FALSE)
rm(twoHT_mpt_data_layout, twoHT_mpt_model)
```

```{r 2HT_mpt_reporting, dependson="2HT_fit"}
twoHT_mpt_params <- cbind(twoHT_mpt_fit$parameters$individual[,1,],
                          twoHT_mpt_fit$parameters$mean[,1, drop=FALSE]
                          )
colnames(twoHT_mpt_params) <- c(paste("Subject", 101:114), "Mean")
twoHT_mpt_params <- t(twoHT_mpt_params)

kable(twoHT_mpt_params, digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "float_left") %>%
  column_spec(1, bold = TRUE)

twoHT_mpt_GOF <- bind_rows(twoHT_mpt_fit$goodness.of.fit$individual,
                           twoHT_mpt_fit$goodness.of.fit$sum)
rownames(twoHT_mpt_GOF) <- c(paste("Subject", 101:114), "Total")

kable(twoHT_mpt_GOF, digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  column_spec(1, bold = TRUE)
```

### Standard
```{r std_2HT_LL}
twoHT <- function(theta) {
  
  FAR <- (1-theta['DN'])*theta[c("GO_Cons", "GO_Neut", "GO_Lib")]
  HR_W <- theta['DO_W'] + ((1-theta['DO_W'])*theta[c("GO_Cons", "GO_Neut", "GO_Lib")])
  HR_S <- theta['DO_S'] + ((1-theta['DO_S'])*theta[c("GO_Cons", "GO_Neut", "GO_Lib")])

  return(list(FAR=FAR, HR_W=HR_W, HR_S=HR_S))
}

twoHT_LL <- function(theta, counts) {
  
  preds <- twoHT(theta)

  LL <- c(dbinom(counts$H_S, size = counts$S_N, prob = preds$HR_S, log=TRUE),
          dbinom(counts$H_W, size = counts$W_N, prob = preds$HR_W, log=TRUE),
          dbinom(counts$FA, size = counts$L_N, prob = preds$FAR, log=TRUE)
          )
  return(-sum(LL))
}

twoHT_G2 <- function(theta, counts) {
  
  preds <- twoHT(theta)

  LL <- c(dbinom(counts$H_S, size = counts$S_N, prob = preds$HR_S, log=TRUE),
          dbinom(counts$H_W, size = counts$W_N, prob = preds$HR_W, log=TRUE),
          dbinom(counts$FA, size = counts$L_N, prob = preds$FAR, log=TRUE)
          )
  return(-sum(LL))
}
```

```{r std_2HT_fit, dependson=c("std_2HT_LL","cell_counts")}
twoHT_std_fit_optimx <- foreach(sub = split(delayed_counts_by_sub_bias,
                                           delayed_counts_by_sub_bias$subject)
                            ) %do% {

    fit <- optimx(par = c("DN"=.5, "DO_W"=.5, "DO_S"=.75,
                          "GO_Cons"=.25, 'GO_Neut'=.5, 'GO_Lib'=.75
                          ),
                  fn = twoHT_LL,
                  method = "nlminb",
                  itnmax = 3000,
                  lower = c(0, 0, 0, 0, 0, 0),
                  upper = c(1, 1, 1, 1, 1, 1),
                  control = list(kkt=FALSE),
                  counts = sub
                  )
    fit$subject <- sub$subject[1]
    fit
  }
rm(fit, sub)
```

```{r std_twoHT_GOF, dependson="std_2HT_fit"}
twoHT_std_fits <- bind_rows(twoHT_std_fit_optimx)

twoHT_std_params <- select(twoHT_std_fits, subject, !!!c("DN", "DO_W", "DO_S", "GO_Cons", "GO_Neut", "GO_Lib"))
twoHT_std_avg_params <- summarise_at(twoHT_std_params,
                                     .vars = c("DN", "DO_W", "DO_S", "GO_Cons", "GO_Neut", "GO_Lib"),
                                     .funs = "mean")

twoHT_std_GOF <- select(twoHT_std_fits, subject, LL = value, fevals, gevals, niter, convcode) %>%
  mutate(LL = -LL) %>%
  left_join(null_LL, by="subject") %>%
  mutate(calc_G2 = -2*(LL - null_LL)) %>%
  mutate(df = 3,
         p.value = pchisq(calc_G2, df=df, lower.tail = FALSE)
         ) %>%
  select(subject, LL, null_LL, calc_G2, df, p.value, fevals:convcode)

twoHT_std_sum_GOF <- select(.data = twoHT_std_GOF,
                            subject, LL, null_LL, calc_G2, df) %>%
  summarise_at(.vars = c("LL", "null_LL", "calc_G2", "df"),
               .funs = "sum"
               ) %>%
  mutate(p.value = pchisq(calc_G2, df=df, lower.tail = FALSE))

rm(twoHT_std_fits)
```

```{r std_twoHT_predictions, dependson="std_2HT_fit"}
FAR_points <- seq(0, 1, .01)

twoHT_std_sub_ROC_preds <- group_by(twoHT_std_params, subject) %>%
  mutate(twoHT = list(
    data.frame(FAR = rep(FAR_points, 2),
               strength = factor(rep(c("W", "S"), each = length(FAR_points)),
                                 levels = c("W", "S")),
               HR = c( ((1-DO_W)/(1-DN)*FAR_points) + DO_W,
                       ((1-DO_S)/(1-DN)*FAR_points) + DO_S
               ))
    
    )) %>%
  select(subject, twoHT) %>%
  unnest()

twoHT_std_avg_ROC_preds <- select(twoHT_std_params, -subject) %>%
  summarise_all("mean") %>%
  summarise(twoHT = list(
    data.frame(FAR = rep(FAR_points, 2),
               strength = factor(rep(c("W", "S"), each = length(FAR_points)),
                                 levels = c("W", "S")),
               HR = c( ((1-DO_W)/(1-DN)*FAR_points) + DO_W,
                       ((1-DO_S)/(1-DN)*FAR_points) + DO_S
               ))
    
    )) %>%
  unnest()
```

```{r std_twoHT_plots, fig.width=9, dependson="std_2HT_fit"}
ggplot(filter(twoHT_std_avg_ROC_preds, HR <= 1),
       aes(x=FAR, y=HR, linetype=strength)) +
  geom_line(size=1.75) +
  geom_point(aes(color=factor(pOld)),
             data = avg_obs_ROC_data,
             size=4) +
  scale_x_continuous("False Alarm Rate", limits = c(0,1),
                     labels = c(0,0.25, 0.5, 0.75, 1)) +
  scale_y_continuous("Hit Rate", limits = c(0,1)) +
  scale_linetype_discrete("Item",
                          labels=c("W" = "'Weak' Target",
                                   "S" = "'Strong' Target")) +
  scale_color_manual("p(Old)", values = c("#d82d2d", "#d8d834", "#17b50c")) +
  guides(colour = guide_legend(override.aes = list(size = 4)),
         shape = guide_legend(override.aes = list(size = 4))) +
  coord_fixed() +
  ggtitle("Two-HT Model ROC (Average)") +
  theme_bw(base_size = 26) +
  theme(plot.title = element_text(hjust=.5),
        strip.background = element_blank(),
        legend.key.width = unit(10,"mm"))

```

```{r std_twoHT_parameters, dependson="std_2HT_fit"}
bind_rows(twoHT_std_params,
          mutate(twoHT_std_avg_params, subject = "Mean")
          ) %>%
  tibble::column_to_rownames(var="subject") %>%
  kable(type="HTML", digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "float_left") %>%
  column_spec(1, bold = TRUE)

bind_rows(select(.data = twoHT_std_GOF,
                 subject, LL, null_LL, calc_G2, df, p.value),
          mutate(.data = twoHT_std_sum_GOF,
                 subject = "Sum")
          ) %>%
  tibble::column_to_rownames(var="subject") %>%
  kable(type="HTML", digits=3) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "float_left") %>%
  column_spec(1, bold = TRUE)
```
