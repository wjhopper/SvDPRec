---
title: "Diffusion SDT Parameter Recovery"
author: "Will Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(rprojroot)
library(Rcpp)
library(kableExtra)
library(optimx)
library(foreach)
library(rtdists)
library(ggplot2)
library(dplyr)
library(tidyr)
library(RcppParallel)
library(dqrng)
library(iterators)
library(doRNG)
root_dir <- rprojroot::is_rstudio_project$find_file()
```

```{r diffusion_functions, cache=TRUE, cache.extra=tools::md5sum(file.path(root_dir, "src", "diffusion.cpp"))}
libdir <- file.path(root_dir, "src", "libs")
if (!dir.exists(libdir)) {
  dir.create(libdir)
}
sourceCpp(file.path(root_dir, "src", "diffusion.cpp"),
          cacheDir = libdir)

sample_parameters <- function(N=500) {
  
  parameters <- data.frame(id = 1:N,
                           a = runif(N, .5, 1.5),
                           v = rnorm(N),
                           t0 = runif(N, 0, .5),
                           z = runif(N, .1, .9),
                           sz = runif(N, .1, .9),
                           sv = rexp(N, 2),
                           st0 = runif(N, 0, .25),
                           crit_old = runif(N, -1,0),
                           crit_new = runif(N, 0, 1)
                           )
  parameters$z <- parameters$z * parameters$a # convert relative to absolute 
  dist_to_closest_boundary <- pmin(parameters$a - parameters$z,
                                   parameters$z)
  parameters$sz <- parameters$sz * dist_to_closest_boundary
  return(parameters)
}

p_diffusion_SDT <- function(x, cutoffs) {
  p <- numeric(length(cutoffs))
  RT <- x[,'RT']
  for (i in 1:length(cutoffs)) {
    p[i] <- sum(RT <= cutoffs[i])
  }
  return(p)
}

summary.diffusion_SDT <- function(x, quantiles=c(.1, .3, .5, .7, .9, 1)) {
  
  x <- as_data_frame(unclass(x))
  
  speeded_quantiles <- group_by(x, speeded_resp) 
  speeded_quantiles <- filter(speeded_quantiles, n() >= 6)
  speeded_quantiles <- summarise(speeded_quantiles,
      quantiles = list(
        data.frame(quantile = quantiles,
                   RT = quantile(RT, quantiles),
                   stringsAsFactors = FALSE
                   )
        )
      )
  speeded_quantiles <- ungroup(speeded_quantiles)

  joint_counts <- group_by(x, speeded_resp, delayed_resp)
  joint_counts <- nest(joint_counts, RT , .key="raw_RT")
  joint_counts <- left_join(speeded_quantiles, joint_counts,
                            by = "speeded_resp")
  joint_counts <- group_by(joint_counts, speeded_resp, delayed_resp)
  joint_counts <- mutate(joint_counts,
                         bin_counts = list(p_diffusion_SDT(x = raw_RT[[1]],
                                                           cutoffs = quantiles[[1]]$RT
                                                           )
                                           )
                          )
  joint_counts <- select(joint_counts, -raw_RT)
  joint_counts <- unnest(joint_counts, quantiles, bin_counts)
  joint_counts <- mutate(joint_counts, 
                         bin_counts = diff(c(0, bin_counts)))
  joint_counts <- ungroup(joint_counts)
  joint_counts <- select(joint_counts,
                         speeded_resp, delayed_resp, quantile, RT, bin_counts)
  joint_counts <- arrange(joint_counts, speeded_resp, delayed_resp)

  return(joint_counts)
}

diffusion_obj <- function(theta, data, fixed=NULL, Nsim=5e4, seed=42){

  theta <- c(theta, fixed)
  boundaries <- c(0,1) # Boundaries to loop over
  set_diffusion_SDT_seed(seed)
  sim_data <- diffusion_SDT(N=Nsim, a = theta[1], v = theta[2],
                            t0 = theta[3], z = theta[4], sz=theta[5],
                            sv = theta[6], st0 = theta[7],
                            crit = theta[8:9]
                            )

  p <- numeric(nrow(data))
  start <- 1

  for (sp_resp in boundaries) {
    for (del_resp in boundaries) {

      resp_index <- data$speeded_resp == sp_resp &
                    data$delayed_resp == del_resp
      sim_responses <- sim_data[,'speeded_resp'] == sp_resp &
                                sim_data[,'delayed_resp'] == del_resp

      # Only proceed if this isn't a missing cell
      if (any(resp_index) && any(sim_responses)) {

        cutpoints <- data$RT[resp_index]
        n_cutpoints <- length(cutpoints)
        cutpoints[n_cutpoints] <- Inf

        # Compute porportion below each cutoff
        resp_proportions <- p_diffusion_SDT(sim_data[sim_responses, , drop=FALSE],
                                            cutpoints)
        # Convert to proportion between each cutoffs
        resp_proportions <- c(resp_proportions[1],
                              diff(resp_proportions)
                              )

        p[start:(start + n_cutpoints - 1)] <- resp_proportions
        start <- start + n_cutpoints
      }
    }
  }
  
  empty_preds <- p == 0
  if (any(empty_preds)) {
    p[empty_preds] <- 5e-06
  }

  filled_cells <- data$bin_counts != 0
  obs_counts <- data$bin_counts[filled_cells]
  exp_counts <- (p/Nsim)*sum(data$bin_counts)
  exp_counts <- exp_counts[filled_cells]
  g2 <- 2*sum(obs_counts*log(obs_counts/exp_counts))
  # if (is.nan(g2) || is.infinite(g2)) {
  #   browser()
  # }
  # cat(g2, "\n")
  return(g2)
}
```

```{r start_cluster}
RcppParallel::setThreadOptions(1)

cluster_setup <- function(cppFiles, lib_paths = .libPaths(),
                          threads=RcppParallel::defaultNumThreads()) {
  # Set lib paths on nodes to same libpaths as "master"
  .libPaths(lib_paths)
  # Compile any necceary C++ files on each node
  for (f in cppFiles) {
    Rcpp::sourceCpp(f)
  }
  # Set the number of threads available for RcppParallel workeres
  RcppParallel::setThreadOptions(threads)
  set_diffusion_SDT_seed(42)
}

cl <- parallel::makeCluster(parallel::detectCores(),
                            outfile = "",
                            methods = FALSE)
invisible(parallel::clusterCall(cl, cluster_setup,
                                cppFiles = file.path(root_dir, "src", "diffusion.cpp"),
                                threads  = 1,
                                lib_paths = .libPaths()
                                )
          )
doParallel::registerDoParallel(cl)
doRNG::registerDoRNG(seed=42)
```

```{r sample_parameters, cache=TRUE, dependson=c("diffusion_functions")}
parameters <- sample_parameters(500)

samples <- foreach(p_row = iterators::iter(select(parameters, -id), "row")) %do%
  {

    theta <- unlist(p_row)
    raw_data <- diffusion_SDT(1000, a = theta["a"], z = theta['z'],
                              v = theta["v"], sv = theta["sv"],
                              t0 = theta["t0"], st0 = theta["st0"],
                              crit = theta[c("crit_old","crit_new")]
                              )
    data <- summary.diffusion_SDT(raw_data)
    list(theta=theta, data=data)
  }
rm(data, raw_data, theta, p_row)
```

## Loss Function Test
```{r null_g2, cache=TRUE, dependson=c("diffusion_functions")}
theta <- c(a = 0.634, v = 0.0465, sv = 2.534, t0 = 0.0782, st0 = 0.1888,
           z = 0.4585, sz = 0.0723, crit_old = -0.355, crit_new = 0.681)

G2 <- foreach(i=1:10000,
              .noexport = c("diffusion_SDT", "set_diffusion_SDT_seed"),
              .packages = c("optimx", "dplyr", "tidyr"),
              .combine = c) %dopar% {
                
    raw_data <- diffusion_SDT(1000, a = theta["a"], z = theta['z'],
                              v = theta["v"], sv = theta["sv"],
                              t0 = theta["t0"], st0 = theta["st0"],
                              crit = theta[c("crit_old","crit_new")]
                              )
    data <- summary.diffusion_SDT(raw_data)
    g2 <- diffusion_obj(theta, data=data, Nsim = 1e5,
                        seed=sample.int(n = .Machine$integer.max, size = 1)
                        )
    g2
  }
```

The histogram below shows the G² statistic for data repeatedly simulated using the same set of parameters. 10,000 "observed" datasets with 1,000 trials are simulated, and the goodness of fit (as computed with the G² statistic) is computed by comparing the counts in each bin from the "observed" data to the counts in each bin from the "model" predictions. The model's predictions are generated by simulating another data set using the same parameters, but using 10,000 trials instead of 1,000. The data-generating paramters are shown in the table below:

```{r table}
kable(t(as.matrix(theta)), digits=3, format="html") %>%
  kable_styling(full_width = FALSE)
```

Since the only theoretical difference between the "observed data sets" and the "model predictions" is random chance (i.e., both are only simulations), the observed G² statistic should follow a X² distribution. In this case, the X² distribution should have 23 degrees of freedom (because there are 6 data bins as defined by the .1, .3, .5, .7, and .9 quantile boundaries, and this parameter set is all but certain to produce observations in all cells of the old/new speeded vs. old/new delayed contingency table). Thus, if the observed G² statistic does not match this reference distribution, there is an RNG error, or an error somewhere in the steps of computing the GOF.

```{r null_g2_plot}
G2 <- G2[!is.nan(G2)]
densities <- hist(G2, freq = FALSE,
                  breaks=seq(0,max(G2)+1, 1),
                  main = expression(paste(G^2, " for Joint Counts")),
                  xlab = expression(G^2)
                  )
xaxis <- seq(0, max(G2), .1)
lines(xaxis, dchisq(xaxis, 23), col="red", lwd=2)
legend(x=max(G2)-20, y = max(densities$density),
       col=c("red"),
       lty=c(1),
       legend=expression(chi[23]^2),
       lwd=2, bty = 'n')
```

## Parameter Optimization
```{r null_g2_recovery, cache=TRUE, dependson=c("diffusion_functions","sample_parameters")}
null_fit_optimx <- foreach(s = samples,
                           .noexport = c("diffusion_SDT", "set_diffusion_SDT_seed"),
                           .packages = c("optimx", "dplyr" , "tidyr")
                           ) %dopar% {

    fit <- optimx(s$theta,
                  fn = diffusion_obj,
                  method = c("L-BFGS-B"),
                  itnmax = 1000,
                  lower = c(0, -5, 0,    0,    0,    0, 0,    -3, -3),
                  upper = c(3,  5, 0.75, 2.99, 0.75, 6, 0.75,  3,  3),
                  control = list(kkt=FALSE, maxit=1000, starttests=FALSE),
                  data = s$data
                  )
    fit
  }

null_fits <- lapply(null_fit_optimx, tibble::rownames_to_column, var="method") %>%
  bind_rows()
null_GOF <- select(null_fits, fevals, gevals, niter, convcode, value)
null_bf_parameters <- select(null_fits, !!!names(parameters)[-1])
```

The histogram below shows the G² statistic for models that are fit using the true data generating parameters as the starting point for parameter optimization. Because there is random noise in the generated data, the best-fitting parameters may not be the data generating parameters. In fact, it is expected that the parameter optimization routine will find parameters that fit *better* than the data generating parameters (i.e., over-fit this specific sample) and the distribution of the G² statistic should be *lower* than the reference X² distribution.

The reference distribution in this specific case is not a single X² distribution. Because the simulated data is not gauranteed to contain observations from all possible cells of the 2 x 2 contingency table (old/new speeded and old/new delayed), some simulated datasets will have fewer counts than others. The possible number of cells, using bins at the .1, .3, .5, .7, and .9 quantile boundaries, are 6, 12, 18 and 24. To produce the reference distribution, X² distributions with 5, 11, 17 and 23 degrees of freedom are weighted according to the proportion of simulated datasets with the corresponding number of cells and summed.

```{r null_g2_recovery_plot}
nCells <- sapply(samples, function(x) nrow(x$data))
weights <- as.vector(table(nCells))/length(null_fit_optimx)

densities <- hist(null_GOF$value, freq = FALSE,
                  breaks=seq(0,max(null_GOF$value)+1, 1),
                  main = expression(paste(G^2, " for Joint Counts")),
                  xlab =  expression(G^2)
                  )
xaxis <- seq(0, max(null_GOF$value), .1)
chi_density <-
  dchisq(xaxis, 5)*weights[1] +
  dchisq(xaxis, 11)*weights[2] +
  dchisq(xaxis, 17)*weights[3] +
  dchisq(xaxis, 23)*weights[4]

lines(xaxis, chi_density, col="red", lwd=2)
legend(x=xaxis[length(xaxis)]-20, y = max(densities$density),
       col=c("red"),
       lty=c(1),
       legend=expression(chi[mix]^2),
       lwd=2, bty = 'n')
```

## Vanilla diffusion model fits to collapsed data
```{r collapsed, cache=TRUE, dependson=c("diffusion_functions","sample_parameters")}
rdiffusion_obj <- function(theta, data, fixed=NULL, Nsim=5e4) {
  
  # cat(theta, "\n")
  theta <- c(theta, fixed)
  boundaries <- c(0,1) # Boundaries to loop over
  
  set.seed(42)
  sim_data <- rdiffusion(n=Nsim,
                         a = theta[1], v = theta[2],
                         t0 = theta[3], z = theta[4],
                         sv = theta["sv"], st0 = theta["st0"],
                         stop_on_error=FALSE)
  sim_data$response <- as.numeric(sim_data$response) - 1
  sim_data <- as.matrix(sim_data)
  colnames(sim_data) <- c("RT", "speeded_resp")
  
  p <- numeric(nrow(data))
  start <- 1

  for (sp_resp in boundaries) {

      resp_index <- data$speeded_resp == sp_resp
      sim_responses <- sim_data[,'speeded_resp'] == sp_resp

      # Only proceed if this isn't a missing cell
      if (any(resp_index) && any(sim_responses)) {

        cutpoints <- data$RT[resp_index]
        n_cutpoints <- length(cutpoints)
        cutpoints[n_cutpoints] <- Inf

        # Compute porportion below each cutoff
        resp_proportions <- p_diffusion_SDT(sim_data[sim_responses, , drop=FALSE],
                                            cutpoints)
        # Convert to proportion between each cutoffs
        resp_proportions <- c(resp_proportions[1],
                              diff(resp_proportions)
                              )

        p[start:(start + n_cutpoints - 1)] <- resp_proportions
        start <- start + n_cutpoints
    }
  }
  
  empty_preds <- p == 0
  if (any(empty_preds)) {
    p[empty_preds] <- 5e-06
    # cat("Empty cell correction triggered\n")
  }

  filled_cells <- data$bin_counts != 0
  obs_counts <- data$bin_counts[filled_cells]
  exp_counts <- (p/Nsim)*sum(data$bin_counts)
  exp_counts <- exp_counts[filled_cells]
  g2 <- 2*sum(obs_counts*log(obs_counts/exp_counts))
  return(g2)
}

diffusion_SDT_collapsed_obj <- function(theta, data, fixed=NULL, Nsim=5e4) {
  
  # cat(theta, "\n")
  theta <- c(theta, fixed)
  boundaries <- c(0,1) # Boundaries to loop over
  set_diffusion_SDT_seed(42)
  sim_data <- diffusion_SDT(Nsim, a = theta[1], v = theta[2],
                            t0 = theta[3], z = theta[4],
                            sv = theta["sv"], st0 = theta["st0"],
                            crit = theta[c("crit_old","crit_new")]
                            )

  p <- numeric(nrow(data))
  start <- 1

  for (sp_resp in boundaries) {

      resp_index <- data$speeded_resp == sp_resp
      sim_responses <- sim_data[,'speeded_resp'] == sp_resp

      # Only proceed if this isn't a missing cell
      if (any(resp_index) && any(sim_responses)) {

        cutpoints <- data$RT[resp_index]
        n_cutpoints <- length(cutpoints)
        cutpoints[n_cutpoints] <- Inf

        # Compute porportion below each cutoff
        resp_proportions <- p_diffusion_SDT(sim_data[sim_responses, , drop=FALSE],
                                            cutpoints)
        # Convert to proportion between each cutoffs
        resp_proportions <- c(resp_proportions[1],
                              diff(resp_proportions)
                              )

        p[start:(start + n_cutpoints - 1)] <- resp_proportions
        start <- start + n_cutpoints
    }
  }
  
  empty_preds <- p == 0
  if (any(empty_preds)) {
    p[empty_preds] <- 5e-06
    # cat("Empty cell correction triggered\n")
  }

  filled_cells <- data$bin_counts != 0
  obs_counts <- data$bin_counts[filled_cells]
  exp_counts <- (p/Nsim)*sum(data$bin_counts)
  exp_counts <- exp_counts[filled_cells]
  g2 <- 2*sum(obs_counts*log(obs_counts/exp_counts))
  return(g2)
}

collapsed_fits_optimx <- foreach(s = samples,
                                 .errorhandling = "pass",
                                 .noexport = c("diffusion_SDT", "set_diffusion_SDT_seed"),
                                 .packages = c("optimx", "dplyr", "tidyr", "rtdists")) %dopar% 
  {

    data <- group_by(s$data, speeded_resp, quantile, RT) %>%
      summarise(bin_counts = sum(bin_counts))

    rdiffusion_fits <- list()
    diffusion_SDT_fits <- list()

    random_starts <- sample_parameters(2)[,-1]

    for (n in 1:nrow(random_starts)) {

      starting_theta <- unlist(random_starts[n,])

      rdiffusion_fits[[n]] <- 
        optimx(starting_theta[c("a","v","t0","z")],
               fn = rdiffusion_obj,
               method = c("nmkb"),
               itnmax = 1000,
               lower = c(0.01, -5, 0,    0.01),
               upper = c(2.5,   5, 0.75, 2.49),
               control = list(kkt=FALSE, maxit=1000),
               data = data,
               fixed = s$theta[c("sz","sv","st0","crit_old","crit_new")]
               )

      diffusion_SDT_fits[[n]] <- 
        optimx(starting_theta[c("a","v","t0","z")],
               fn = diffusion_SDT_collapsed_obj,
               method = c("nmkb"),
               itnmax = 1000,
               lower = c(0.01, -5, 0,    0.01),
               upper = c(2.5,   5, 0.75, 2.49),
               control = list(kkt=FALSE, maxit=1000),
               data = data,
               fixed = s$theta[c("sz","sv","st0","crit_old","crit_new")]
               )
    }
    
    list(starting_theta = random_starts,
         diffusion_SDT_fits = diffusion_SDT_fits,
         rdiffusion_fits = rdiffusion_fits)
  }
```

```{r collapsed_recovery_plots, fig.width=9}
names(collapsed_fits_optimx) <- 1:length(collapsed_fits_optimx)

collapsed_fits_optimx <- Filter(function(x) { class(x)[1]=='list' },
                                collapsed_fits_optimx)

diffusion_SDT_recovered <- lapply(
  collapsed_fits_optimx,
  function(x) {
    G2 <- sapply(x$diffusion_SDT_fits, `[[`, "value")
    minG2 <- which(G2==min(G2))[1]
    x$diffusion_SDT_fits[[minG2]]
})

diffusion_SDT_recovered <- bind_rows(diffusion_SDT_recovered, .id="id")

rdiffusion_recovered <- lapply(
  collapsed_fits_optimx,
  function(x) {
    G2 <- sapply(x$rdiffusion_fits, `[[`, "value")
    minG2 <- which(G2==min(G2))[1]
    x$rdiffusion_fits[[minG2]]
})

rdiffusion_recovered <- bind_rows(rdiffusion_recovered, .id="id")

collapsed_recovered_fits <- bind_rows("rdiffusion" = rdiffusion_recovered,
                                      "diffusion_SDT" = diffusion_SDT_recovered,
                                      .id="type")

collapsed_GOF <- select(collapsed_recovered_fits, type, id, fevals, gevals, niter, convcode, value)
collapsed_parameters <- select(collapsed_recovered_fits, type, id, a, v, t0, z) %>%
  mutate(id=as.integer(id))

inner_join(gather(collapsed_parameters, key="parameter", value="est", -id, -type),
           gather(parameters[, c("id","a","v","t0","z")], key="parameter", value="real", -id),
           by=c("id", "parameter")
           ) %>%
  ggplot(aes(x=real,y=est)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  facet_grid(parameter~type, scales = "free")

chi_cutoff <- qchisq(.999, 11)
removed <- filter(collapsed_GOF, value > chi_cutoff) %>%
  count(type)
filter(collapsed_GOF, value <= chi_cutoff) %>%
  ggplot(aes(x=value)) +
  geom_histogram(aes(y=..density..),
                 breaks=seq(0, chi_cutoff+1, 1)
                 ) +
  facet_wrap(~type, ncol=1) +
  stat_function(fun=dchisq, color="red", args=list(df=11)) +
  geom_label(data = removed,
             mapping = aes(label = paste(n, "Removed")),
             x=chi_cutoff -5, y= .1) +
  ggtitle("G2 Distribution")
```

```{r random_theta_recovery, cache=TRUE, dependson=c("diffusion_functions","sample_parameters")}
rec_fits_optimx <- foreach(s = samples,
                           .error = "pass",
                           .noexport = c("diffusion_SDT", "set_diffusion_SDT_seed"),
                           .packages = c("optimx", "dplyr" , "tidyr")) %dopar% {

    best_value <- Inf
    best_start <- NULL
    n <- 1
    while (n <= 2) {

      starting_theta <- unlist(sample_parameters(1))[-1] #[-1] to drop id column
      fit <- optimx(starting_theta,
                    fn = diffusion_obj,
                    method = c("nmkb"),
                    itnmax = 1000,
                    lower = c(0, -5, 0,    0,    0,    0, 0,    -3, -3),
                    upper = c(3,  5, 0.75, 2.99, 0.75, 6, 0.75,  3,  3),
                    control = list(kkt=FALSE, maxit=1000),
                    data = s$data
                    )

      if (fit$value < best_value) {
        best_value <- fit$value
        best_fit <- fit
        best_start <- starting_theta
      }
      
      n <- n + 1
    }

    if (best_value == Inf) {
      best_fit <- fit
    }
    
    list(starting_theta=best_start, fit=best_fit)
  }
```

```{r tidy_recovered_params}
names(rec_fits_optimx) <- 1:length(rec_fits_optimx)
# Remove any datasets that errored out
rec_fits_optimx <- Filter(function(x) { class(x)[1]=='list' },
                          rec_fits_optimx)

recovered_fits <- lapply(lapply(rec_fits_optimx, `[[`, 'fit'),
                         tibble::rownames_to_column, var="method") %>%
  bind_rows()

recovered_GOF <- select(recovered_fits, fevals, gevals, niter, convcode, value)
recovered_parameters <- select(recovered_fits, !!!names(parameters)[-1])
```

```{r random_recovery_plot}
all_params <- bind_rows(real = parameters,
                        est = tibble::rowid_to_column(recovered_parameters,
                                                      var = "id"),
                        .id="type")
x <- all_params %>%
  gather(key="parameter",value = "value", -id, -type) %>%
  spread(key="type",value="value")

ggplot(x, aes(x=real,y=est)) +
  geom_point() +
  facet_wrap(~parameter, nrow=3, scales = "free")
```

```{r stopCluster}
parallel::stopCluster(cl)
```
