---
title: "2HT Modeling"
author: "William Hopper"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", cache=TRUE)
options(knitr.kable.NA = '-')
library(gamlss.dist)
library(rprojroot)
library(kableExtra)
library(optimx)
library(foreach)
library(tidyr)
library(ggplot2)
library(dplyr)
root_dir <- rprojroot::is_rstudio_project$find_file()
```


```{css css}
.main-container {
    max-width: 1200px;
}
img {
  padding-top: 10px;
}
```


```{r discrete_race_exgaussians}
## mu, sigma & nu should be vectors of length 2
## First element should be parameter for detect distribution
## Second element should be parameter for guess distribution

## Weight is also vector of length
## First element is probability of detection being available
## Second element is probability of guessing correctly
## These are independent probabilities, need not sum to 1
dcRT <- function(x, mu, sigma, nu, weights) {
  
  pDetect <- weights[1]
  pGuess_correct <- weights[2]
  
  p_detect_process_unfinished <- gamlss.dist::pexGAUS(x, mu[1], sigma[1], nu[1], lower.tail = FALSE)
  p_guess_process_unfinished <- gamlss.dist::pexGAUS(x, mu[2], sigma[2], nu[2], lower.tail = FALSE)
  
  detect_RT_density <- gamlss.dist::dexGAUS(x, mu[1], sigma[1], nu[1])
  guess_RT_density <- gamlss.dist::dexGAUS(x, mu[2], sigma[2], nu[2])
  
  
  correct_RT_density <- 
    # Detect RT's, weighted by probability you can detect and haven't given up & guessed yet
    pDetect * p_guess_process_unfinished * detect_RT_density + 
    # Guess RT's, weighted by probability you could detect but give up "early" and guess correctly
    pDetect * p_detect_process_unfinished * pGuess_correct * guess_RT_density + 
    # uess RT's, weighted by probability you can not detect but guess correctly
    (1-pDetect) * pGuess_correct * guess_RT_density
  
  return(correct_RT_density)
}

## mu, sigma & nu should be vectors of length 2
## Nu is mean of exponential process (also denoted as tao sometimes)
## First element should be parameter for detect distribution
## Second element should be parameter for guess distribution

## Weight is also vector of length
## First element is probability of detection being available
## Second element is probability of guessing *incorrectly*
## These are independent probabilities, need not sum to 1

deRT <- function(x, mu, sigma, nu, weights) {
  ## mu, sigma & nu should be vectors of length 2
  pDetect <- weights[1]
  pGuess_incorrect <- 1-weights[2]
  
  p_detect_process_unfinished <- gamlss.dist::pexGAUS(x, mu[1], sigma[1], nu[1], lower.tail = FALSE)
  guess_RT_density <- gamlss.dist::dexGAUS(x, mu[2], sigma[2], nu[2])
  
  incorrect_RT_density <- # sum of:
    # Guess RT's, weighted by probability you could detect but give up "early" and guess incorrectly 
    pDetect * p_detect_process_unfinished * pGuess_incorrect * guess_RT_density +
    # Guess RT's, weighted by probability detection is not availble and you guess incorrectly
    (1-pDetect) * pGuess_incorrect * guess_RT_density
  
  return(incorrect_RT_density)
  }
```


```{r twoHT}
twoHT <- function(detect, guess) {
  
  FAR <- (1-detect['dNew.L'])*guess
  HR_W <- detect['dOld.W'] + (1-detect['dOld.W'])*guess 
  HR_S <- detect['dOld.S'] + (1-detect['dOld.S'])*guess

  return(list(FAR=FAR, HR_W=HR_W, HR_S=HR_S))
}

```


```{r objective_functions}

DR_predictions <- function(parameters, data) {

  if ( !("mu.dn" %in% names(parameters)) ) {
    parameters["mu.dn"] <- parameters["mu.do"]
  }

  data$predicted_p <- numeric(nrow(data))

  for (strength in unique(data$strength)) {

    condition_index <- data$strength==strength
    
    if (strength == "L") {
      mu_detect <- parameters["mu.dn"]
      detect_correctly <- parameters['dNew.L']
      guess_correctly <- 1 - parameters['gOld']
    } else {
      mu_detect <- parameters["mu.do"]
      detect_correctly <- parameters[paste0('dOld.', strength)]
      guess_correctly <- parameters['gOld']
    }

    for (acc in unique(data$speeded_correct)) {

      if (acc) {
        density_fn = dcRT
      } else {
        density_fn = deRT
      }

      index_vector <- condition_index & data$speeded_correct == acc 
      cutpoints <- c(0, data$value[index_vector])
      cutpoints[length(cutpoints)] <- Inf

      p <- numeric(length(cutpoints)-1)
      for (bin_number in 1:length(p)) {

        x <- integrate(density_fn, cutpoints[bin_number], cutpoints[bin_number+1],
                       mu = c(mu_detect, parameters["mu.g"]),
                       sigma = parameters[c("sigma","sigma")],
                       nu = parameters[c("nu","nu")],
                       weights = c(detect_correctly, guess_correctly)
                       )
        p[bin_number] <- x$value
      }

      data$predicted_p[index_vector] <- p
    }
  }

  return(data)
}

DR_quantiles <- function(parameters, data) {

  if ( !("mu.dn" %in% names(parameters)) ) {
    parameters["mu.dn"] <- parameters["mu.do"]
  }

  data$predicted_qValue <- numeric(nrow(data))

  for (strength in unique(data$strength)) {

    condition_index <- data$strength==strength
    
    if (strength == "L") {
      mu_detect <- parameters["mu.dn"]
      detect_correctly <- parameters['dNew.L']
      guess_correctly <- 1 - parameters['gOld']
    } else {
      mu_detect <- parameters["mu.do"]
      detect_correctly <- parameters[paste0('dOld.', strength)]
      guess_correctly <- parameters['gOld']
    }

    n_samples <- 1000
    n_detect_trials <- rbinom(1, size = n_samples, p = detect_correctly)
    detect_RTs <- c(gamlss.dist::rexGAUS(n_detect_trials,
                                         mu = mu_detect,
                                         sigma = parameters["sigma"],
                                         nu = parameters["nu"]),
                    rep(Inf, n_samples - n_detect_trials)
                    )

    guess_RTs <- gamlss.dist::rexGAUS(n_samples,
                                      mu = parameters["mu.g"],
                                      sigma = parameters["sigma"],
                                      nu = parameters["nu"]
                                      )

    RTs <- pmin(detect_RTs, guess_RTs)
    detect_wins <- detect_RTs == RTs
    accuracy <- logical(n_samples)
    accuracy[detect_wins] <- TRUE
    accuracy[!detect_wins] <- as.logical(rbinom(sum(!detect_wins), 1, guess_correctly))

    data$predicted_qValue[data$speeded_correct] <-
      quantile(RTs[accuracy], c(.1, .3, .5, .7, .9, 1))
    
    data$predicted_qValue[!data$speeded_correct] <-
      quantile(RTs[!accuracy], c(.1, .3, .5, .7, .9, 1))
  }

  return(data)
}

DR_LL <- function(parameters, data){

  data$predicted_p <- numeric(nrow(data))
  log_likelihood <- 0

  for (strength in unique(data$strength)) {

    condition_index <- data$strength==strength
    
    if (strength == "L") {
      mu_detect <- parameters["mu.dn"]
      detect_correctly <- parameters['dNew.L']
      guess_correctly <- 1 - parameters['gOld']
    } else {
      mu_detect <- parameters["mu.do"]
      detect_correctly <- parameters[paste0('dOld.', strength)]
      guess_correctly <- parameters['gOld']
    }

    for (acc in unique(data$speeded_correct)) {

      if (acc) {
        density_fn = dcRT
      } else {
        density_fn = deRT
      }

      index_vector <- condition_index & data$speeded_correct == acc 
      cutpoints <- c(0, data$value[index_vector])
      cutpoints[length(cutpoints)] <- Inf

      p <- numeric(length(cutpoints)-1)
      for (bin_number in 1:length(p)) {

        x <- integrate(density_fn, cutpoints[bin_number], cutpoints[bin_number+1],
                       mu = c(mu_detect, parameters["mu.g"]),
                       sigma = parameters[c("sigma","sigma")],
                       nu = parameters[c("nu","nu")],
                       weights = c(detect_correctly, guess_correctly)
                       )
        p[bin_number] <- x$value
      }

      data$predicted_p[index_vector] <- p
    }

    condition_index <- data$strength==strength
    bin_counts <- data$bin_counts[condition_index]
    log_likelihood <- log_likelihood + dmultinom(x = bin_counts, size = sum(bin_counts),
                                                 prob = data$predicted_p[condition_index],
                                                 log = TRUE)
  }

  return(-log_likelihood)
}


twoHT_LL <- function(detect, guess, counts) {
  FA <- (1-detect['dNew.L'])*guess
  HR_W <- detect['dOld.W'] + (1-detect['dOld.W'])*guess 
  HR_S <- detect['dOld.S'] + (1-detect['dOld.S'])*guess

  LL <- c(dbinom(counts$H_S, size = counts$S_N, prob = HR_S, log=TRUE),
          dbinom(counts$H_W, size = counts$W_N, prob = HR_W, log=TRUE),
          dbinom(counts$FA, size = counts$L_N, prob = FA, log=TRUE)
          )
  return(-sum(LL))
}


twoHT_DR_LL_sum <- function(theta, data, fixed=NULL, p_names=NULL) {
  
  if (!is.null(p_names)) {
    names(theta) <- p_names
    p_names <- names(theta)
  }

  if ( !("mu.dn" %in% names(theta)) ) {
    theta["mu.dn"] <- theta["mu.do"]
  }
  twoHT_negLL <- twoHT_LL(detect=theta[c("dNew.L", "dOld.W", "dOld.S")],
                          guess=theta[c("gC", "gN", "gL")], #this order matters
                          counts = data$biased
                          )
  
  DR_negLL <- DR_LL(theta[c("dNew.L", "dOld.W", "dOld.S", "gOld",
                            "mu.do", "mu.g", "mu.dn", "sigma", "nu")],
                    data = data$speeded
                    )
  
  negLL <- twoHT_negLL + DR_negLL
  if (is.infinite(negLL) || is.nan(negLL)) {
    negLL <- .Machine$double.xmax
  }
  return(negLL)
}
```


```{r load_data}
load(file.path(root_dir, "data", "SvDPRec.Rdata"))
test <- select(test, -list)
```


# By-Subject Modeling

```{r cell_counts}
delayed_counts_by_sub_bias <- filter(test, !is.na(type)) %>%
  select(-starts_with("speeded")) %>%
  rename(correct = delayed_correct) %>%
  count(subject, strength, pOld, correct) %>%
  complete(subject, strength, pOld, correct,
           fill = list(n=0)) %>%
  unite(col = "resp_type", strength, correct) %>%
  spread(resp_type, n) %>%
  rename(FA = L_FALSE, CR = L_TRUE,
         M_S = S_FALSE, H_S = S_TRUE,
         M_W = W_FALSE, H_W = W_TRUE) %>%
  mutate(L_N = FA + CR,
         S_N = M_S + H_S,
         W_N = M_W + H_W) %>%
  select(subject, pOld, FA, CR, L_N, H_S, M_S, S_N, H_W, M_W, W_N)

speeded_RT_choice_quantiles <- filter(test, !is.na(type)) %>%
  filter(speeded_RT > 200) %>%
  mutate(speeded_RT = speeded_RT/1000) %>%
  group_by(subject, strength, speeded_correct) %>%
  summarise(quintiles = list(
              data.frame(quantile = c("10%", "30%", "50%", "70%", "90%", "100%"),
                         value = quantile(speeded_RT, c(.1, .3, .5, .7, .9, 1)),
                         bin_counts = floor(n() * c(.1, .2, .2, .2, .2, .1)),
                         stringsAsFactors = FALSE)
              )) %>%
  ungroup() %>%
  unnest()

speeded_acc <- filter(test, !is.na(type)) %>%
  group_by(subject, strength) %>%
  summarise(acc = mean(speeded_correct))
```


```{r start_cluster, dependson=c("discrete_race_exgaussians", "objective_functions", "fit_two_mu", "fit_three_mu")}
cl <- parallel::makeCluster(parallel::detectCores(),
                            outfile = "",
                            methods = FALSE)

doParallel::registerDoParallel(cl)
```


```{r data_list, dependson="cell_counts"}
subjectwise_datalist <- Map(
  function(x,y) { list("speeded" = x,"biased" = y)},
  split(speeded_RT_choice_quantiles, speeded_RT_choice_quantiles$subject),
  split(delayed_counts_by_sub_bias, delayed_counts_by_sub_bias$subject)
  )
```

```{r fit_two_mu, dependson=c("discrete_race_exgaussians", "objective_functions", "cell_counts")}

twoHT_plus_DR_fits_twoMu <- foreach(sub = subjectwise_datalist,
                                    .packages = c("optimx", "gamlss.dist")
                                    ) %dopar%
  {

  theta <- c("dNew.L" = .5, "dOld.W" = .5, "dOld.S"=.75, 
             "gOld"=.5, "gC" = .5, "gN" = .5, "gL" = .5,
             "mu.do" = .5, "mu.g" = .75, "sigma" = .25, "nu" = .25
             )
    fit <- optimx(theta,
                  fn = twoHT_DR_LL_sum,
                  method = "nlminb",
                  itnmax = 3000,
                  lower = c(.01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01),
                  upper = c(1,   1,   1,   1,   1,   1,   1,   2,   2,   .5,  .5),
                  control = list(kkt=FALSE),
                  data = sub
                  )

    fit$subject <- sub$speeded$subject[1]
    return(fit)
  }
```


```{r fit_three_mu, dependson=c("discrete_race_exgaussians", "objective_functions", "cell_counts")}

twoHT_plus_DR_fits_threeMu <- foreach(sub = subjectwise_datalist,
                                      .packages = c("optimx", "gamlss.dist")
                                      ) %dopar%
  {

    theta <- c("dNew.L" = .5, "dOld.W" = .5, "dOld.S"=.75,
               "gOld"=.5,"gC" = .5, "gN" = .5, "gL" = .5,
               "mu.do" = .5, "mu.g" = .75, "mu.dn" = .5, "sigma" = .25, "nu" = .25
               )
    fit <- optimx(theta,
                  fn = twoHT_DR_LL_sum,
                  method = "nlminb",
                  itnmax = 3000,
                  lower = c(.01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01),
                  upper = c(1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   .5,  .5),
                  control = list(kkt=FALSE),
                  data = sub
                  )

    fit$subject <- sub$speeded$subject[1]
    return(fit)
  }
```


```{r stop_cluster, dependson=c("discrete_race_exgaussians", "objective_functions", "fit_two_mu", "fit_three_mu")}
parallel::stopCluster(cl)
```


```{r combine_fits, dependson=c("fit_two_mu", "fit_three_mu")}

npar <- lapply(c(twoHT_plus_DR_fits_twoMu, twoHT_plus_DR_fits_threeMu),
               attr, which="npar"
               )

twoHT_plus_DR_fits <- bind_rows("yoked" = bind_rows(twoHT_plus_DR_fits_twoMu),
                                "unyoked" = bind_rows(twoHT_plus_DR_fits_threeMu),
                                .id="model"
                                ) %>%
  mutate(nPar = unlist(npar))
```


```{r parameters, dependson=c("fit_two_mu", "fit_three_mu")}

param_names <- colnames(coef(twoHT_plus_DR_fits_threeMu[[1]]))

fitted_param_list <- lapply(c("yoked" = twoHT_plus_DR_fits_twoMu,
                              "unyoked" = twoHT_plus_DR_fits_threeMu
                              ),
                            FUN = function(x) { unlist(as.data.frame(coef(x))) }
                            )

twoHT_plus_DR_params_subject <- select(.data = twoHT_plus_DR_fits, model, subject, !!!param_names)

twoHT_plus_DR_params_avg <- group_by(.data = twoHT_plus_DR_params_subject, model) %>%
  summarise_at(.vars = param_names, .funs = "mean")
```


```{r speeded_acc, dependson="parameters"}

predicted_probabilities <- mapply(DR_predictions,
                                  fitted_param_list,
                                  lapply(subjectwise_datalist, `[[`, "speeded"),
                                  SIMPLIFY = FALSE
                                  ) %>%
  bind_rows(.id="model") %>%
  mutate(model = sub("[[:digit:]]+", "", model)) %>%
  select(-bin_counts) %>%
  rename(p = predicted_p)


obs_p <- group_by(.data = speeded_RT_choice_quantiles,
           subject, strength, speeded_correct) %>%
  mutate(p = bin_counts/sum(bin_counts)) %>%
  group_by(subject, strength) %>%
  mutate(p = p*c(rep(sum(bin_counts[!speeded_correct])/sum(bin_counts), 6),
                 rep(sum(bin_counts[speeded_correct])/sum(bin_counts), 6))
         ) %>%
  ungroup()


probabilities <- bind_rows(predicted_probabilities,
                           select(mutate(obs_p, model = "obs"), -bin_counts)
                           ) %>% 
  rename(type=model)


accuracy <- group_by(probabilities,
                     type, subject, strength, speeded_correct
                     ) %>%
  summarise(p = sum(p)) %>%
  ungroup()
```

```{r speeded_quantiles, dependson=c("parameters", "speeded_acc")}
predicted_quantiles <- mapply(DR_quantiles,
                              fitted_param_list,
                              lapply(subjectwise_datalist, `[[`, "speeded"),
                              SIMPLIFY = FALSE
                              ) %>% 
  bind_rows(.id="model") %>%
  mutate(model = sub("[[:digit:]]+", "", model)) %>%
  select(-bin_counts, -value) %>%
  rename(RT = predicted_qValue)

obs_q <- select(speeded_RT_choice_quantiles, -bin_counts) %>%
  mutate(model = "obs") %>%
  rename(RT = value)

quantiles <- bind_rows(predicted_quantiles,
                       obs_q) %>%
  rename(type = model) %>%
  filter(quantile != "100%")

conditional_quantiles <- left_join(quantiles, accuracy,
                                   by = c("type","subject","strength", "speeded_correct")
                                   ) %>%
  mutate(p = p*(as.numeric(sub("%", "", quantile)) / 100))

conditional_quantiles_avg <- group_by(.data = conditional_quantiles,
                                      type, strength, speeded_correct, quantile) %>%
    summarise_at(c("RT","p"), mean) %>%
    ungroup()
```


```{r factor_ordering, dependson="speeded_quantiles"}
conditional_quantiles_avg <- mutate(conditional_quantiles_avg,
                                    strength = factor(strength, levels = c("L","W","S"))
                                    )
quantiles <- mutate(quantiles, strength = factor(strength, levels = c("L","W","S")))
```


```{r ROC_predictions, dependson="parameters"}


obs_ROC_by_sub <- mutate(delayed_counts_by_sub_bias,
         FAR = FA / L_N,
         HR_W = H_W / W_N,
         HR_S = H_S / S_N
         ) %>%
  select(subject, pOld, FAR, HR_W, HR_S) %>%
  gather(key = "strength", value = "HR", HR_W, HR_S) %>%
  arrange(subject, desc(strength)) %>%
  mutate(strength = sub("HR_", "", strength, fixed=TRUE))


obs_ROC_avg <- group_by(obs_ROC_by_sub, pOld, strength) %>%
  summarise_at(.vars = c("HR", "FAR"), .funs = "mean")


FAR_points <- seq(0, 1, .01)

twoHT_ROC_curve_subject <- twoHT_plus_DR_params_subject %>%
  select(subject, model, dNew.L, dOld.W, dOld.S) %>%
  rowwise() %>%
  mutate(twoHT = list(
    data.frame(FAR = rep(FAR_points, 2),
               strength = rep(c("W", "S"), each = length(FAR_points)),
               HR = c( ((1-dOld.W)/(1-dNew.L)*FAR_points) + dOld.W,
                       ((1-dOld.S)/(1-dNew.L)*FAR_points) + dOld.S
                      )
               )
    )) %>%
  select(subject, model, twoHT) %>%
  unnest() %>%
  filter(HR <= 1)


twoHT_ROC_curve_avg <- twoHT_plus_DR_params_avg %>%
  select(model, dNew.L, dOld.W, dOld.S) %>%
  rowwise() %>%
  mutate(twoHT = list(
    data.frame(FAR = rep(FAR_points, 2),
               strength = rep(c("W", "S"), each = length(FAR_points)),
               HR = c( ((1-dOld.W)/(1-dNew.L)*FAR_points) + dOld.W,
                       ((1-dOld.S)/(1-dNew.L)*FAR_points) + dOld.S
                      )
               )
    )) %>%
  select(model, twoHT) %>%
  unnest() %>%
  filter(HR <= 1)


twoHT_ROC_points_subject <- twoHT_plus_DR_params_subject %>%
  rowwise() %>%
  mutate(x = list(data.frame(
           twoHT(detect = c("dNew.L"=dNew.L, "dOld.W"=dOld.W, "dOld.S"=dOld.S),
                 guess = c("gC"=gC, "gN"=gN, "gL"=gL)
                 ),
           pOld = c(.25, .5, .75)
         ))) %>%
  select(subject, model, x) %>%
  unnest() %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  filter(HR <= 1) %>%
  select(subject, model, pOld, strength, FAR, HR) %>%
  bind_rows(pred = ., 
            mutate(obs_ROC_by_sub, model="obs")
            )


twoHT_ROC_points_avg <- twoHT_plus_DR_params_subject %>%
  select(model, dNew.L, dOld.W, dOld.S, gC, gN, gL) %>%
  group_by(model) %>%
  summarise_all("mean") %>%
  ungroup() %>%
  rowwise() %>%
  mutate(x = list(data.frame(
           twoHT(detect = c("dNew.L"=dNew.L, "dOld.W"=dOld.W, "dOld.S"=dOld.S),
                 guess = c("gC"=gC, "gN"=gN, "gL"=gL)
                 ),
           pOld = c(.25, .5, .75),
           stringsAsFactors = FALSE
         ))) %>%
  select(model, x) %>%
  unnest() %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  filter(HR <= 1) %>%
  select(model, pOld, strength, FAR, HR) %>%
  bind_rows(pred = ., 
            mutate(obs_ROC_avg, model="obs")
            )

```


```{r GOF, dependson=c("fit_two_mu", "fit_three_mu")}
speeded_RT_LL <- speeded_RT_choice_quantiles %>%
  group_by(subject, strength) %>%
  mutate(observed_p = bin_counts/sum(bin_counts)) %>%
  summarise(null_LL = dmultinom(bin_counts, sum(bin_counts), observed_p, log=TRUE)) %>%
  group_by(subject) %>%
  summarise(null_LL = sum(null_LL)) %>%
  ungroup()


delayed_acc_LL <- mutate(delayed_counts_by_sub_bias,
                         FA_LL = dbinom(FA, L_N, FA / L_N, log = TRUE),
                         HW_LL = dbinom(H_W, W_N, H_W / W_N, log = TRUE),
                         HS_LL = dbinom(H_S, S_N, H_S / S_N, log = TRUE),
                         LL = FA_LL + HW_LL + HS_LL) %>% 
  select(subject, pOld, LL) %>%
  group_by(subject) %>%
  summarise(null_LL = sum(LL)) %>%
  ungroup()


null_LL <- left_join(speeded_RT_LL, delayed_acc_LL,
                     by="subject", suffix=c(".RT",".acc")) %>%
  transmute(subject,
            null_LL = null_LL.RT + null_LL.acc)


twoHT_plus_DR_GOF_subject <-
  dplyr::select(.data=twoHT_plus_DR_fits,
                subject, model, value, nPar, fevals, gevals, niter, convcode) %>%
  mutate(LL = -value) %>%
  left_join(x = .,  y = null_LL,
            by = "subject") %>%
  mutate(G2 = -2*(LL - null_LL),
         df = 42 - nPar,
         p = pchisq(G2, df = df, lower.tail = FALSE)
         ) %>%
  dplyr::select(subject, model, LL, G2, df, p, fevals, gevals, niter, convcode)


twoHT_plus_DR_GOF_sum <- group_by(twoHT_plus_DR_GOF_subject, model) %>%
  summarise_at(.vars=c("LL",  "G2", "df"), "sum")
```


## Averaged Results

```{r ROC_avg_plot, fig.width=7, fig.height=7, dependson="ROC_predictions"}
ggplot(twoHT_ROC_points_avg,
       aes(x=FAR, y=HR, color=model, shape = factor(pOld))) +
  geom_point(size=4) +
  geom_line(aes(linetype=strength, group=strength),
            data = filter(twoHT_ROC_points_avg, model=="obs"),
            size=1.75
            ) +
  geom_line(aes(x=FAR, y=HR, color=model, linetype=strength),
            data = twoHT_ROC_curve_avg,
            size=1.75,
            inherit.aes = FALSE
            ) +
  scale_x_continuous("False Alarm Rate",
                     limits = c(0,1),
                     labels = c(0,0.25, 0.5, 0.75, 1)
                     ) +
  scale_y_continuous("Hit Rate", limits = c(0,1)) +
  scale_linetype_discrete("Strength",
                          limits = c("W", "S"),
                          labels = c("W" = "Weak", "S" = "Strong")
                          ) +
  scale_shape_discrete("p(Old)",
                       limits = c(.25, .5, .75),
                       labels = c("25%", "50%", "75%")
                       ) +
  scale_colour_brewer("Model",
                      palette = "Set1",
                      limits = c("obs", "unyoked", "yoked"),
                      labels = c("yoked" = "Two Mu's",
                                 "unyoked" = "Three Mu's",
                                 "obs" = "Observed")
                      ) +
  coord_fixed() +
  ggtitle("Two-HT Model ROC (Averaged)") +
  theme_bw(base_size = 16) +
  theme(plot.title = element_text(hjust=.5),
        strip.background = element_blank(),
        legend.key.size = unit(2, "lines"),
        legend.position = c(.6, .2),
        legend.box = "horizontal")
```


```{r QP_plot, fig.width=10, fig.height=7, dependson=c("speeded_quantiles","speeded_accuracy")}

ggplot(conditional_quantiles_avg,
       aes(x=RT, y=p, color=type, linetype=speeded_correct, shape=type)) +
  geom_point(size=2) +
  geom_line(size=1) +
  facet_grid(~strength,
             labeller = as_labeller(c("L" = "Lure", "W" = "Weak", "S" = "Strong"))
             ) +
  scale_linetype_discrete("Accuracy",
                          limits = c("FALSE", "TRUE"),
                          labels = c("Incorrect", "Correct")
                          ) +
  scale_colour_brewer("Model",
                      palette = "Set1",
                      limits = c("obs", "unyoked", "yoked"),
                      labels = c("yoked" = "Two Mu's",
                                 "unyoked" = "Three Mu's",
                                 "obs" = "Observed")
                      ) +
  scale_shape_manual("Model",
                     values = c(17, 15, 16),
                     limits = c("obs", "unyoked", "yoked"),
                     labels = c("yoked" = "Two Mu's",
                                "unyoked" = "Three Mu's",
                                "obs" = "Observed")
                     ) +
  guides(linetype = guide_legend(order = 1)) +
  ggtitle("2LT + Discrete Race",
          subtitle="Conditional Quantiles (Pooled)") +
  scale_x_continuous("Response Time (s.)") +
  theme_bw(base_size=16) +
  theme(plot.title = element_text(hjust=.5),
        plot.subtitle = element_text(hjust=.5),
        strip.background = element_blank(),
        legend.key.width = unit(2,"line")
        )
```


```{r param_summary_tables, dependson="parameters"}

formatted_names_map <- c(subject="Subject", model="model", dNew.L="DN<sub>L</sub>", dOld.W="DO<sub>W</sub>", 
                         dOld.S="DO<sub>S</sub>", gOld = "GO", gC="GO<sub>C</sub>", gN="GO<sub>N</sub>",
                         gL="GO<sub>L</sub>", mu.do="μ<sub>D</sub>", mu.g="μ<sub>G</sub>",
                         mu.dn="μ<sub>DN</sub>", sigma="\U03C3", nu="v", G2="G<sup>2</sup>", LL="LL",
                         null_LL="Null LL", df="df", p="p(X<sup>2</sup>)",fevals="fevals",
                         gevals="gevals", niter="niter", convcode="convcode"
                         )


left_join(twoHT_plus_DR_params_subject,
          select(twoHT_plus_DR_GOF_subject, subject, model, G2),
          by=c("subject", "model")
          ) %>%
  kable(digits=3,
        col.names = formatted_names_map[names(.)],
        escape=FALSE,
        ) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::column_spec(1:2, bold=TRUE) %>%
  kableExtra::collapse_rows(1)
```


## Individual Subjects

```{r ROC_subject_plot, dependson="ROC_predictions", fig.height=12, fig.width=9}

ggplot(twoHT_ROC_points_subject,
       aes(x=FAR, y=HR, color=model, shape = factor(pOld))) +
  geom_point() +
  geom_line(aes(linetype=strength, group=strength),
            data = filter(twoHT_ROC_points_subject, model=="obs")
            ) +
  geom_line(aes(x=FAR, y=HR, color=model, linetype=strength),
            data = mutate(twoHT_ROC_curve_subject, type="pred"),
            inherit.aes = FALSE
            ) +
  facet_wrap(~ subject,
             labeller = labeller(subject = label_both,
                                 .multi_line = FALSE),
             ncol=4
             ) +
  scale_x_continuous("False Alarm Rate",
                     limits = c(0,1),
                     labels = c(0,0.25, 0.5, 0.75, 1)
                     ) +
  scale_y_continuous("Hit Rate", limits = c(0,1)) +
  scale_linetype_discrete("Strength",
                          limits = c("W", "S"),
                          labels = c("W" = "Weak", "S" = "Strong")
                          ) +
  scale_shape_discrete("p(Old)",
                       limits = c(.25, .5, .75),
                       labels = c("25%", "50%", "75%")
                       ) +
  scale_colour_brewer("Model",
                      palette = "Set1",
                      limits = c("obs", "unyoked", "yoked"),
                      labels = c("yoked" = "Two Mu's",
                                 "unyoked" = "Three Mu's",
                                 "obs" = "Observed")
                      ) +
  coord_fixed() +
  guides(shape = guide_legend(override.aes = list(size=3))) +
  ggtitle("Predicted ROC for delayed judgments") +
  theme_bw(base_size = 16) +
  theme(legend.position = c(.75, .1),
        legend.box = "horizontal"
        )
```

```{r RT_plots, dependson=c("parameters", "GOF", "speeded_quantiles","speeded_accuracy"), fig.width=10, results="asis"}

for (s in unique(twoHT_plus_DR_params_subject$subject)) {
  
  cat(sprintf("<h3>Subject %s</h3>", s))
  
  subject_params <- filter(twoHT_plus_DR_params_subject, subject == s)
  subject_GOF <- filter(twoHT_plus_DR_GOF_subject, subject == s)
  
  kable(subject_params,
        digits = 3,
        col.names = formatted_names_map[names(subject_params)],
        escape = FALSE) %>%
    kableExtra::kable_styling(full_width = FALSE, position = "float_left") %>%
    print()

    kable(subject_GOF,
          digits = 3,
          col.names = formatted_names_map[names(subject_GOF)],
          escape = FALSE) %>%
    kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
    print()
    
  acc_plot <-
    ggplot(filter(accuracy, subject == s, speeded_correct),
           aes(x=strength, y=p, shape=type, color=strength)
           ) +
    geom_point(size=2, stroke=2,
               position = position_dodge(width=.35)
               ) +
    scale_shape_manual(NULL,
                       values=c(16, 15, 4),
                       breaks = c("obs", "yoked", "unyoked"),
                       labels = c("Observed", "Two Mu's", "Three Mu's")
                       ) +
    scale_color_discrete("Strength",
                         limits = c("L", "W", "S"),
                         labels = c("L" = "Lure",
                                    "W" = "Weak\nTarget",
                                    "S" = "Strong\nTarget")
                         ) +
    scale_y_continuous("Percent Correct", limits = c(0, 1)) +
    scale_x_discrete("",
                     labels = c("", "", ""),
                     limits = c("L","W","S"),
                     expand = c(0, .3)
                     ) +
    theme(legend.key.height = unit(9, 'mm'),
          axis.title.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.text.x = element_blank()
          )
  
quantile_plot <-
    ggplot(filter(quantiles, subject == s),
           aes(x=quantile, y=RT, shape=type, color=strength)) +
    geom_point(size=1.5) +
    geom_line(aes(group=type)) +
    facet_grid(speeded_correct ~ strength,
               labeller = labeller(speeded_correct = as_labeller(
                                    c("TRUE" = "Correct",
                                      "FALSE" = "Error")
                                    ),
                                    strength = as_labeller(
                                      c("L" = "Lure",
                                        "S" = "Strong Target",
                                        "W" = "Weak Target")
                                    )
                                   )
               ) +
    scale_shape_manual(NULL,
                       values=c(16, 15, 4),
                       breaks = c("obs", "yoked", "unyoked"),
                       labels = c("Observed", "Two Mu's", "Three Mu's")
                       ) +
    scale_color_discrete("Strength",
                         limits = c("L", "W", "S"),
                         labels = c("L" = "Lure",
                                    "W" = "Weak\nTarget",
                                    "S" = "Strong\nTarget")
                         ) +
    scale_y_continuous("RT Quantile Value (s.)") +
    guides(color=FALSE, shape=FALSE)
  
  gridExtra::grid.arrange(acc_plot, quantile_plot, nrow=1,
                          widths=c(.27, .73)
                          )
}
```

## Parameter Comparison
```{r yoked_vs_unyoked, fig.width=9, fig.height=12}
x <- twoHT_plus_DR_params_subject %>%
  mutate(mu.dn = coalesce(mu.dn, mu.do)) %>%
  gather(key="param", value="value", -subject, -model) %>%
  spread(key=model, value=value)

y <- gather(select(twoHT_plus_DR_GOF_subject, subject, model, G2),
            key = "param", value="value", -subject, -model
            ) %>%
  spread(key=model, value=value)

ggplot(bind_rows(x, y),
       aes(x=yoked, y=unyoked)
       ) +
  geom_point() +
  geom_abline(intercept = 0, slope=1) +
  facet_wrap(~param, scales = "free", ncol=3) +
  xlab("Two Mu's") +
  ylab("Three Mu's") +
  ggtitle("Three vs. Two Mu Models")

rm(x, y)
```


# Aggregated Modeling

```{r cell_counts_pooled}
delayed_counts_by_bias <-
  select(.data = delayed_counts_by_sub_bias, -subject) %>%
  group_by(pOld) %>%
  summarise_all(.funs = "sum")

obs_ROC_data_pooled <-
  mutate(delayed_counts_by_bias,
         FAR = FA / L_N,
         HR_W = H_W / W_N,
         HR_S = H_S / S_N) %>%
  select(pOld, FAR, HR_W, HR_S) %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  select(pOld, strength, FAR, HR)


n_lte_RT <- function(x, y) {
  
  N <- numeric(length(x))
  for (i in 1:length(x)) {
    N[i] <- sum(y <= x[i])
  }
  
  if (!is.null(names(x))) {
    names(N) <- names(x)
  }
  
  return(N)
}

test <- filter(test, !is.na(type)) %>%
  filter(speeded_RT > 200) %>%
  mutate(speeded_RT = speeded_RT/1000)

pooled_RT_bin_counts <-
  group_by(.data = speeded_RT_choice_quantiles,
           strength, speeded_correct, quantile) %>%
  summarise(value = mean(value)) %>%
  ungroup() %>%
  arrange(strength, speeded_correct, value) %>%
  nest(quantile, value, .key = "quantiles") %>%
  left_join(x=.,
            y=summarise(group_by(.data=test, strength, speeded_correct),
                        speeded_RT=list(speeded_RT)
                        ),
            by=c("strength", "speeded_correct")
            ) %>%
  group_by(strength, speeded_correct) %>%
  mutate(bin_counts = list(n_lte_RT(x = quantiles[[1]]$value, y = unlist(speeded_RT)))
         ) %>%
  select(strength, speeded_correct, quantiles, bin_counts) %>%
  unnest() %>%
  mutate(bin_counts = c(bin_counts[1], diff(bin_counts)),
         p = bin_counts/sum(bin_counts)
         ) %>%
  ungroup()

speeded_acc_pooled <-
  group_by(.data = test, strength) %>%
  summarise(acc = mean(speeded_correct))
```


```{r data_list_pooled, dependson="cell_counts_pooled"}
pooled_datalist <- list("speeded" = pooled_RT_bin_counts,
                        "biased" = delayed_counts_by_bias
                        )
```


```{r fit_two_mu_pooled, dependson=c("discrete_race_exgaussians", "objective_functions", "cell_counts_pooled")}

theta <- c("dNew.L" = .5, "dOld.W" = .5, "dOld.S"=.75, 
           "gOld"=.5, "gC" = .5, "gN" = .5, "gL" = .5,
           "mu.do" = .5, "mu.g" = .75, "sigma" = .25, "nu" = .25
           )

twoHT_plus_DR_fits_twoMu_pooled <-
  optimx(theta,
         fn = twoHT_DR_LL_sum,
         method = "nlminb",
         itnmax = 3000,
         lower = c(.01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01),
         upper = c(1,   1,   1,   1,   1,   1,   1,   2,   2,   .5,  .5),
         control = list(kkt = FALSE),
         data = pooled_datalist
         )
```


```{r fit_three_mu_pooled, dependson=c("discrete_race_exgaussians", "objective_functions", "cell_counts_pooled")}

theta <- c("dNew.L" = .5, "dOld.W" = .5, "dOld.S"=.75,
           "gOld"=.5,"gC" = .5, "gN" = .5, "gL" = .5,
           "mu.do" = .5, "mu.g" = .75, "mu.dn" = .5, "sigma" = .25, "nu" = .25
           )
twoHT_plus_DR_fits_threeMu_pooled <-
  optimx(theta,
         fn = twoHT_DR_LL_sum,
         method = "nlminb",
         itnmax = 3000,
         lower = c(.01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01),
         upper = c(1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   .5,  .5),
         control = list(kkt = FALSE),
         data = pooled_datalist
         )
```

```{r combine_fits_pooled, dependson=c("fit_two_mu_pooled", "fit_three_mu_pooled")}

npar_pooled <- lapply(list(twoHT_plus_DR_fits_twoMu_pooled,
                           twoHT_plus_DR_fits_threeMu_pooled
                           ), 
                      attr, which = "npar"
                      )

twoHT_plus_DR_fits_pooled <- bind_rows("yoked" = twoHT_plus_DR_fits_twoMu_pooled,
                                       "unyoked" = twoHT_plus_DR_fits_threeMu_pooled,
                                       .id = "model"
                                       ) %>%
  mutate(nPar = unlist(npar_pooled))
```


```{r parameters_pooled, dependson=c("fit_two_mu_pooled", "fit_three_mu_pooled", "combine_fits_pooled")}

param_names_pooled <- colnames(coef(twoHT_plus_DR_fits_threeMu_pooled))

fitted_param_list_pooled <- lapply(list("yoked" = twoHT_plus_DR_fits_twoMu_pooled,
                                        "unyoked" = twoHT_plus_DR_fits_threeMu_pooled
                                        ),
                                   FUN = function(x) { unlist(as.data.frame(coef(x))) }
                                   )

twoHT_plus_DR_params_pooled <- select(.data = twoHT_plus_DR_fits_pooled, model, !!!param_names_pooled)
```


```{r speeded_acc_pooled, dependson="parameters_pooled"}

predicted_probabilities_pooled <-
  mapply(DR_predictions,
         fitted_param_list_pooled,
         list(pooled_datalist$speeded, pooled_datalist$speeded),
         SIMPLIFY = FALSE
         ) %>%
  bind_rows(.id="model") %>%
  select(-bin_counts, -p) %>%
  rename(p = predicted_p)


obs_p_pooled <- group_by(.data = pooled_RT_bin_counts, strength) %>%
  mutate(p = p*c(rep(sum(bin_counts[!speeded_correct])/sum(bin_counts), 6),
                 rep(sum(bin_counts[speeded_correct])/sum(bin_counts), 6))
         ) %>%
  ungroup()


probabilities_pooled <- bind_rows(predicted_probabilities_pooled,
                                  select(mutate(obs_p_pooled, model = "obs"),
                                         -bin_counts)
                                  ) %>% 
  rename(type=model)


accuracy_pooled <- group_by(.data = probabilities_pooled,
                            type, strength, speeded_correct
                            ) %>%
  summarise(p = sum(p)) %>%
  ungroup()
```


```{r speeded_quantiles_pooled, dependson=c("parameters_pooled", "speeded_acc_pooled")}
predicted_quantiles_pooled <-
  mapply(DR_quantiles,
         fitted_param_list_pooled,
         list(pooled_datalist$speeded, pooled_datalist$speeded),
         SIMPLIFY = FALSE
         ) %>% 
  bind_rows(.id="model") %>%
  select(-bin_counts, -value, -p) %>%
  rename(RT = predicted_qValue)

obs_q_pooled <- select(pooled_RT_bin_counts, -bin_counts, -p) %>%
  mutate(model = "obs") %>%
  rename(RT = value)

quantiles_pooled <- bind_rows(predicted_quantiles_pooled,
                              obs_q_pooled) %>%
  rename(type = model) %>%
  filter(quantile != "100%")

conditional_quantiles_pooled <- left_join(quantiles_pooled, accuracy_pooled,
                                          by = c("type" ,"strength", "speeded_correct")
                                   ) %>%
  mutate(p = p*(as.numeric(sub("%", "", quantile)) / 100),
         strength = factor(strength, levels = c("L","W","S"))
         )

quantiles_pooled <- mutate(quantiles_pooled, strength = factor(strength, levels = c("L","W","S")))
```


```{r ROC_predictions_pooled, dependson="parameters_pooled"}

twoHT_ROC_curve_pooled <- twoHT_plus_DR_params_pooled %>%
  select(model, dNew.L, dOld.W, dOld.S) %>%
  rowwise() %>%
  mutate(twoHT = list(
    data.frame(FAR = rep(FAR_points, 2),
               strength = rep(c("W", "S"), each = length(FAR_points)),
               HR = c( ((1-dOld.W)/(1-dNew.L)*FAR_points) + dOld.W,
                       ((1-dOld.S)/(1-dNew.L)*FAR_points) + dOld.S
                      )
               )
    )) %>%
  select(model, twoHT) %>%
  unnest() %>%
  filter(HR <= 1)


twoHT_ROC_points_pooled <- twoHT_plus_DR_params_pooled %>%
  rowwise() %>%
  mutate(x = list(data.frame(
           twoHT(detect = c("dNew.L"=dNew.L, "dOld.W"=dOld.W, "dOld.S"=dOld.S),
                 guess = c("gC"=gC, "gN"=gN, "gL"=gL)
                 ),
           pOld = c(.25, .5, .75)
         ))) %>%
  select(model, x) %>%
  unnest() %>%
  gather(key="strength", value="HR", HR_W, HR_S) %>%
  mutate(strength = sub("HR_", "", strength)) %>%
  filter(HR <= 1) %>%
  select(model, pOld, strength, FAR, HR) %>%
  bind_rows(pred = ., 
            mutate(obs_ROC_data_pooled, model="obs")
            )
```


```{r GOF_pooled, dependson=c("fit_two_mu_pooled", "fit_three_mu_pooled")}
speeded_RT_LL_pooled <- group_by(obs_p_pooled, strength) %>%
  summarise(null_LL = dmultinom(bin_counts, sum(bin_counts), p, log=TRUE)) %>%
  summarise(null_LL = sum(null_LL))


delayed_acc_LL_pooled <- mutate(delayed_counts_by_bias,
                                FA_LL = dbinom(FA, L_N, FA / L_N, log = TRUE),
                                HW_LL = dbinom(H_W, W_N, H_W / W_N, log = TRUE),
                                HS_LL = dbinom(H_S, S_N, H_S / S_N, log = TRUE),
                                LL = FA_LL + HW_LL + HS_LL
                                ) %>% 
  select(pOld, LL) %>%
  summarise(null_LL = sum(LL))


twoHT_plus_DR_GOF_pooled <-
  dplyr::select(.data=twoHT_plus_DR_fits_pooled,
                model, value, nPar, fevals, gevals, niter, convcode) %>%
  mutate(LL = -value,
         null_LL = speeded_RT_LL_pooled$null_LL + delayed_acc_LL_pooled$null_LL,
         G2 = -2*(LL - null_LL),
         df = 42 - nPar,
         p = pchisq(G2, df = df, lower.tail = FALSE)
         ) %>%
  dplyr::select(model, LL, G2, df, p, fevals, gevals, niter, convcode)
```


```{r ROC_plot_pooled, fig.width=7, fig.height=7, dependson="ROC_predictions_pooled"}

ggplot(twoHT_ROC_points_pooled,
       aes(x=FAR, y=HR, color=model, shape = factor(pOld))) +
  geom_line(aes(x=FAR, y=HR, color=model, linetype=strength),
            data = twoHT_ROC_curve_pooled,
            size=1.75,
            inherit.aes = FALSE
            ) +
  geom_line(aes(linetype=strength, group=strength),
            data = filter(twoHT_ROC_points_pooled, model=="obs"),
            size=1.75
            ) +
  geom_point(size=4) +
  scale_x_continuous("False Alarm Rate",
                     limits = c(0,1),
                     labels = c(0,0.25, 0.5, 0.75, 1)
                     ) +
  scale_y_continuous("Hit Rate", limits = c(0,1)) +
  scale_linetype_discrete("Strength",
                          limits = c("W", "S"),
                          labels = c("W" = "Weak", "S" = "Strong")
                          ) +
  scale_shape_discrete("p(Old)",
                       limits = c(.25, .5, .75),
                       labels = c("25%", "50%", "75%")
                       ) +
  scale_colour_brewer("Model",
                      palette = "Set1",
                      limits = c("obs", "unyoked", "yoked"),
                      labels = c("yoked" = "Two Mu's",
                                 "unyoked" = "Three Mu's",
                                 "obs" = "Observed")
                      ) +
  coord_fixed() +
  ggtitle("Two-HT Model ROC (Pooled Data)") +
  theme_bw(base_size = 16) +
  theme(plot.title = element_text(hjust=.5),
        strip.background = element_blank(),
        legend.key.size = unit(2, "lines"),
        legend.position = c(.6, .2),
        legend.box = "horizontal")
```


```{r QP_plot_pooled, fig.width=10, fig.height=7, dependson=c("speeded_quantiles_pooled","speeded_accuracy_pooled")}

ggplot(conditional_quantiles_pooled,
       aes(x=RT, y=p, color=type, linetype=speeded_correct, shape=type)) +
  geom_point(size=2) +
  geom_line(size=1) +
  facet_grid(~strength,
             labeller = as_labeller(c("L" = "Lure", "W" = "Weak", "S" = "Strong"))
             ) +
  scale_linetype_discrete("Accuracy",
                          limits = c("FALSE", "TRUE"),
                          labels = c("Incorrect", "Correct")
                          ) +
  scale_colour_brewer("Model",
                      palette = "Set1",
                      limits = c("obs", "unyoked", "yoked"),
                      labels = c("yoked" = "Two Mu's",
                                 "unyoked" = "Three Mu's",
                                 "obs" = "Observed")
                      ) +
  scale_shape_manual("Model",
                     values = c(17, 15, 16),
                     limits = c("obs", "unyoked", "yoked"),
                     labels = c("yoked" = "Two Mu's",
                                "unyoked" = "Three Mu's",
                                "obs" = "Observed")
                     ) +
  guides(linetype = guide_legend(order = 1)) +
  ggtitle("2LT + Discrete Race",
          subtitle="Conditional Quantiles (Pooled)") +
  scale_x_continuous("Response Time (s.)") +
  theme_bw(base_size=16) +
  theme(plot.title = element_text(hjust=.5),
        plot.subtitle = element_text(hjust=.5),
        strip.background = element_blank(),
        legend.key.width = unit(2,"line")
        )
```

```{r pooled_parameter_tables}
kable(twoHT_plus_DR_params_pooled,
      digits=3,
      col.names = formatted_names_map[names(twoHT_plus_DR_params_pooled)],
      escape=FALSE) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::column_spec(1, bold=TRUE)

kable(twoHT_plus_DR_GOF_pooled,
      digits=3,
      col.names = formatted_names_map[names(twoHT_plus_DR_GOF_pooled)],
      escape=FALSE) %>%
  kableExtra::kable_styling(full_width = FALSE) %>%
  kableExtra::column_spec(1, bold=TRUE)
```
